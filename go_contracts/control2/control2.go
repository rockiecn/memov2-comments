// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package control2

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// OrderIn is an auto generated low-level Go binding around an user-defined struct.
type OrderIn struct {
	UIndex uint64
	PIndex uint64
	Start  uint64
	End    uint64
	Size   uint64
	Nonce  uint64
	TIndex uint8
	Sprice *big.Int
}

// PWIn is an auto generated low-level Go binding around an user-defined struct.
type PWIn struct {
	PIndex uint64
	TIndex uint8
	Pay    *big.Int
	Lost   *big.Int
}

// RoleOut is an auto generated low-level Go binding around an user-defined struct.
type RoleOut struct {
	IsBan    bool
	IsActive bool
	RType    uint8
	Index    uint64
	GIndex   uint64
	Owner    common.Address
	Next     common.Address
	Extra    []byte
}

// Control2ABI is the input ABI used to generate the binding from.
const Control2ABI = "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_inst\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"name\":\"AddOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"pi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ti\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lost\",\"type\":\"uint256\"}],\"name\":\"ProWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"i\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isLock\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ti\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"Recharge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"i\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ti\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualMoney\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"},{\"internalType\":\"bytes[5]\",\"name\":\"signs\",\"type\":\"bytes[5]\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"uIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"pIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"size\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"tIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"sprice\",\"type\":\"uint256\"}],\"internalType\":\"structOrderIn\",\"name\":\"ps\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"uSign\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"pSign\",\"type\":\"bytes\"}],\"name\":\"addOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"uIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"pIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"size\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"tIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"sprice\",\"type\":\"uint256\"}],\"internalType\":\"structOrderIn\",\"name\":\"ps\",\"type\":\"tuple\"},{\"internalType\":\"uint64[]\",\"name\":\"kIndexes\",\"type\":\"uint64[]\"},{\"internalType\":\"bytes[]\",\"name\":\"ksigns\",\"type\":\"bytes[]\"}],\"name\":\"addRepair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inst\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"pIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"tIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"pay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lost\",\"type\":\"uint256\"}],\"internalType\":\"structPWIn\",\"name\":\"ps\",\"type\":\"tuple\"},{\"internalType\":\"uint64[]\",\"name\":\"kIndexes\",\"type\":\"uint64[]\"},{\"internalType\":\"bytes[]\",\"name\":\"ksigns\",\"type\":\"bytes[]\"}],\"name\":\"proWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_ui\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isLock\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"recharge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"uIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"pIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"size\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"tIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"sprice\",\"type\":\"uint256\"}],\"internalType\":\"structOrderIn\",\"name\":\"ps\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"uSign\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"pSign\",\"type\":\"bytes\"}],\"name\":\"subOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_i\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]"

// Control2FuncSigs maps the 4-byte function signature to its string representation.
var Control2FuncSigs = map[string]string{
	"4bf1b134": "add(address,bool,bytes[5])",
	"ae9d0b40": "addOrder(address,(uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256),bytes,bytes)",
	"af99c59a": "addRepair(address,(uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256),uint64[],bytes[])",
	"de9375f2": "auth()",
	"bd6b2222": "inst()",
	"022914a7": "owners(address)",
	"54aa6642": "proWithdraw(address,(uint64,uint8,uint256,uint256),uint64[],bytes[])",
	"f661f9e3": "recharge(address,uint64,uint8,bool,uint256)",
	"42f45166": "subOrder(address,(uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256),bytes,bytes)",
	"54fd4d50": "version()",
	"9b4c757a": "withdraw(address,uint64,uint8,uint256)",
}

// Control2Bin is the compiled bytecode used for deploying new contracts.
var Control2Bin = "0x60806040526001805461ffff60a01b1916600160a11b1790553480156200002557600080fd5b5060405162003ae238038062003ae2833981016040819052620000489162000097565b600180546001600160a01b039384166001600160a01b03199182161790915560028054929093169116179055620000cf565b80516001600160a01b03811681146200009257600080fd5b919050565b60008060408385031215620000ab57600080fd5b620000b6836200007a565b9150620000c6602084016200007a565b90509250929050565b613a0380620000df6000396000f3fe6080604052600436106100a05760003560e01c80639b4c757a116100645780639b4c757a14610188578063ae9d0b40146101a8578063af99c59a146101c8578063bd6b2222146101e8578063de9375f214610220578063f661f9e31461024057600080fd5b8063022914a7146100ac57806342f45166146100f15780634bf1b1341461011357806354aa66421461013357806354fd4d501461015357600080fd5b366100a757005b600080fd5b3480156100b857600080fd5b506100dc6100c7366004612ecf565b60006020819052908152604090205460ff1681565b60405190151581526020015b60405180910390f35b3480156100fd57600080fd5b5061011161010c3660046130f6565b610260565b005b34801561011f57600080fd5b5061011161012e36600461318e565b610819565b34801561013f57600080fd5b5061011161014e366004613364565b610992565b34801561015f57600080fd5b5060015461017590600160a01b900461ffff1681565b60405161ffff90911681526020016100e8565b34801561019457600080fd5b506101116101a3366004613425565b610f14565b3480156101b457600080fd5b506101116101c33660046130f6565b611460565b3480156101d457600080fd5b506101116101e3366004613476565b61191a565b3480156101f457600080fd5b50600254610208906001600160a01b031681565b6040516001600160a01b0390911681526020016100e8565b34801561022c57600080fd5b50600154610208906001600160a01b031681565b34801561024c57600080fd5b5061011161025b3660046134e7565b611cb0565b3360009081526020819052604090205460ff166102985760405162461bcd60e51b815260040161028f9061354b565b60405180910390fd5b600254604051633ec7d5b960e01b8152600760048201526001600160a01b03909116908190633ec7d5b990602401602060405180830381865afa1580156102e3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610307919061356e565b60c08501516040516340d5dc7f60e11b815260ff90911660048201526001600160a01b0391909116906381abb8fe906024016040805180830381865afa158015610355573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610379919061358b565b505060008061038b86868660016120c0565b915091504286606001516001600160401b031611156103ec5760405162461bcd60e51b815260206004820152601860248201527f734f726465723a656e64206d6f7265207468616e206e6f770000000000000000604482015260640161028f565b604051633ec7d5b960e01b8152600a60048201526001600160a01b03841690633ec7d5b990602401602060405180830381865afa158015610431573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610455919061356e565b6001600160a01b031663248d02a087836040518363ffffffff1660e01b8152600401610482929190613630565b600060405180830381600087803b15801561049c57600080fd5b505af11580156104b0573d6000803e3d6000fd5b505050506000826001600160a01b0316886001600160a01b03161461080f57604051633ec7d5b960e01b8152600660048201526000906001600160a01b03861690633ec7d5b990602401602060405180830381865afa158015610517573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061053b919061356e565b604051636565250360e11b81526001600160a01b038b811660048301529192509082169063caca4a0690602401602060405180830381865afa158015610585573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105a99190613656565b604051637738515f60e01b81526001600160401b0382166004820152600360248201529092506000906001600160a01b03831690637738515f90604401608060405180830381865afa158015610603573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106279190613673565b5092505050806001600160401b0316846001600160401b03161461067f5760405162461bcd60e51b815260206004820152600f60248201526e39a7b93232b91d33903234b33332b960891b604482015260640161028f565b600061068a85612521565b90506000610190826001600160a01b0316636d23f6c86040518163ffffffff1660e01b8152600401602060405180830381865afa1580156106cf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106f391906136d2565b60ff168c604001518d6060015161070a9190613705565b6001600160401b03168d60e00151610722919061372d565b61072c919061372d565b6107369190613762565b60405162904c3960e21b81526001600160401b0387166004820152600160248201529091506001600160a01b0383169063024130e490604401600060405180830381600087803b15801561078957600080fd5b505af115801561079d573d6000803e3d6000fd5b5050505060c08b01516040516355d3d7ef60e01b815260ff9091166004820152602481018290526001600160a01b038316906355d3d7ef90604401600060405180830381600087803b1580156107f257600080fd5b505af1158015610806573d6000803e3d6000fd5b50505050505050505b5050505050505050565b823b60008190036108615760405162461bcd60e51b81526020600482015260126024820152713732b2b21031b7b73a3930b1ba1030b2323960711b604482015260640161028f565b6040516bffffffffffffffffffffffff1930606090811b821660208401526218591960ea1b603484015286901b16603782015283151560f81b604b820152600090604c0160408051601f1981840301815290829052805160209091012060015463a96bba9d60e01b83529092506001600160a01b03169063a96bba9d906108ee90849087906004016137c3565b600060405180830381600087803b15801561090857600080fd5b505af115801561091c573d6000803e3d6000fd5b5050604080516001600160a01b038916815287151560208201527f938b2a24c98e4e542127ffa74a91e48942c2bddccae3b6d75f82bfda7bbc0807935001905060405180910390a15050506001600160a01b03919091166000908152602081905260409020805460ff1916911515919091179055565b3360009081526020819052604090205460ff166109c15760405162461bcd60e51b815260040161028f9061354b565b600254604051633ec7d5b960e01b8152600760048201526001600160a01b03909116908190633ec7d5b990602401602060405180830381865afa158015610a0c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a30919061356e565b60208501516040516340d5dc7f60e11b815260ff90911660048201526001600160a01b0391909116906381abb8fe906024016040805180830381865afa158015610a7e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aa2919061358b565b5050604051633ec7d5b960e01b815260066004820152600090819081906001600160a01b03851690633ec7d5b990602401602060405180830381865afa158015610af0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b14919061356e565b8751604051637738515f60e01b81526001600160401b039091166004820152600260248201526001600160a01b039190911690637738515f90604401608060405180830381865afa158015610b6d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b919190613673565b50925092509250826001600160a01b0316886001600160a01b03161480610bc95750816001600160a01b0316886001600160a01b0316145b610c0c5760405162461bcd60e51b8152602060048201526014602482015273383bb4ba34323930bb9d34b6361031b0b63632b960611b604482015260640161028f565b60008760000151886020015189604001518a60600151604051602001610c67949392919060c09490941b6001600160c01b031916845260f89290921b6001600160f81b03191660088401526009830152602982015260490190565b604051602081830303815290604052805190602001209050610c8b8282898961266f565b604051633ec7d5b960e01b8152600a60048201529093506000906001600160a01b03871690633ec7d5b990602401602060405180830381865afa158015610cd6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cfa919061356e565b604080516352381f0b60e11b81528b516001600160401b03908116600483015260208d015160ff166024830152918c0151604482015260608c0151606482015290851660848201526001600160a01b03919091169063a4703e169060a4016020604051808303816000875af1158015610d77573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d9b919061381a565b90506000610190856001600160a01b0316636d23f6c86040518163ffffffff1660e01b8152600401602060405180830381865afa158015610de0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e0491906136d2565b610e119060ff168461372d565b610e1c90600361372d565b610e269190613762565b60208b01516040516355d3d7ef60e01b815260ff9091166004820152602481018290529091506001600160a01b038616906355d3d7ef90604401600060405180830381600087803b158015610e7a57600080fd5b505af1158015610e8e573d6000803e3d6000fd5b5050505089600001516001600160401b03168b6001600160a01b03167f3ea20fac35aae529e59d08cd5e2b0481108ccd275b50215084c05039245766db8c602001518d604001518e60600151604051610eff9392919060ff9390931683526020830191909152604082015260600190565b60405180910390a35050505050505050505050565b3360009081526020819052604090205460ff16610f435760405162461bcd60e51b815260040161028f9061354b565b600254604051633ec7d5b960e01b8152600760048201526001600160a01b03909116906000908290633ec7d5b990602401602060405180830381865afa158015610f91573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fb5919061356e565b6040516340d5dc7f60e11b815260ff861660048201526001600160a01b0391909116906381abb8fe906024016040805180830381865afa158015610ffd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611021919061358b565b50604051633ec7d5b960e01b81526006600482015290915060009081906001600160a01b03851690633ec7d5b990602401602060405180830381865afa15801561106f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611093919061356e565b604051637738515f60e01b81526001600160401b0389166004820152600060248201526001600160a01b039190911690637738515f90604401608060405180830381865afa1580156110e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061110d9190613673565b509250925050816001600160a01b0316886001600160a01b03161461116a5760405162461bcd60e51b81526020600482015260136024820152723bb4ba34323930bb9d34b6361031b0b63632b960691b604482015260640161028f565b604051633ec7d5b960e01b8152600a60048201526000906001600160a01b03861690633ec7d5b990602401602060405180830381865afa1580156111b2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111d6919061356e565b6040516312ce36af60e11b81526001600160401b038a16600482015260ff89166024820152604481018890526001600160a01b03919091169063259c6d5e906064016020604051808303816000875af1158015611237573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061125b919061381a565b9050808611801561127557506000826001600160401b0316115b15611326576112848187613833565b9550600061129183612521565b6040516312ce36af60e11b81526001600160401b038b16600482015260ff8a166024820152604481018990526001600160a01b03919091169063259c6d5e906064016020604051808303816000875af11580156112f2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611316919061381a565b9050611322818361384a565b9150505b604051633ec7d5b960e01b8152600c60048201526001600160a01b03861690633ec7d5b990602401602060405180830381865afa15801561136b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061138f919061356e565b60405163530345bb60e01b81526001600160a01b038681166004830152858116602483015260448201849052919091169063530345bb90606401600060405180830381600087803b1580156113e357600080fd5b505af11580156113f7573d6000803e3d6000fd5b50506040805160ff8b168152602081018a90529081018490526001600160401b038b1692506001600160a01b038c1691507f8cf9f6665801a7a41feb765d72a4472b5f7d327ed18c77c6e81d2bb5622cd8c09060600160405180910390a3505050505050505050565b3360009081526020819052604090205460ff1661148f5760405162461bcd60e51b815260040161028f9061354b565b600254604051633ec7d5b960e01b8152600760048201526001600160a01b039091169060009081908390633ec7d5b990602401602060405180830381865afa1580156114df573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611503919061356e565b60c08701516040516340d5dc7f60e11b815260ff90911660048201526001600160a01b0391909116906381abb8fe906024016040805180830381865afa158015611551573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611575919061358b565b9150915060008061158988888860006120c0565b91509150816001600160a01b0316896001600160a01b0316146115e25760405162461bcd60e51b815260206004820152601160248201527030a7b93232b91d34b6361031b0b63632b960791b604482015260640161028f565b60006115ed82612521565b6001600160a01b0316636d23f6c86040518163ffffffff1660e01b8152600401602060405180830381865afa15801561162a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061164e91906136d2565b604051633ec7d5b960e01b8152600a60048201529091506001600160a01b03871690633ec7d5b990602401602060405180830381865afa158015611696573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116ba919061356e565b6001600160a01b03166389cdc7438a83856040518463ffffffff1660e01b81526004016116e993929190613862565b600060405180830381600087803b15801561170357600080fd5b505af1158015611717573d6000803e3d6000fd5b50505050831561190e57604051633ec7d5b960e01b8152600960048201526000906001600160a01b03881690633ec7d5b990602401602060405180830381865afa158015611769573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061178d919061356e565b6040808c015160608d015160808e015160e08f0151935163027be70560e31b81526001600160401b039384166004820152918316602483015291909116604482015260648101919091526001600160a01b0391909116906313df3828906084016020604051808303816000875af115801561180c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611830919061381a565b9050801561190c57604051633ec7d5b960e01b8152600560048201526001600160a01b03808816916340c10f19918a1690633ec7d5b990602401602060405180830381865afa158015611887573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118ab919061356e565b6040516001600160e01b031960e084901b1681526001600160a01b03909116600482015260248101849052604401600060405180830381600087803b1580156118f357600080fd5b505af1158015611907573d6000803e3d6000fd5b505050505b505b50505050505050505050565b3360009081526020819052604090205460ff166119495760405162461bcd60e51b815260040161028f9061354b565b600254604051633ec7d5b960e01b8152600760048201526001600160a01b03909116908190633ec7d5b990602401602060405180830381865afa158015611994573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119b8919061356e565b60c08501516040516340d5dc7f60e11b815260ff90911660048201526001600160a01b0391909116906381abb8fe906024016040805180830381865afa158015611a06573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a2a919061358b565b505083516001600160401b031615611a7a5760405162461bcd60e51b8152602060048201526013602482015272615265706169723a7569206e6f74207a65726f60681b604482015260640161028f565b604051633ec7d5b960e01b81526006600482015260009081906001600160a01b03841690633ec7d5b990602401602060405180830381865afa158015611ac4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ae8919061356e565b6020870151604051637738515f60e01b81526001600160401b039091166004820152600260248201526001600160a01b039190911690637738515f90604401608060405180830381865afa158015611b44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b689190613673565b509250509150816001600160a01b0316876001600160a01b031614611bc45760405162461bcd60e51b815260206004820152601260248201527130a932b830b4b91d34b6361031b0b63632b960711b604482015260640161028f565b6000611bcf87612c27565b9050611bdd8282888861266f565b50604051633ec7d5b960e01b8152600a60048201526001600160a01b03851690633ec7d5b990602401602060405180830381865afa158015611c23573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c47919061356e565b6001600160a01b03166380faaf8888846040518363ffffffff1660e01b8152600401611c74929190613630565b600060405180830381600087803b158015611c8e57600080fd5b505af1158015611ca2573d6000803e3d6000fd5b505050505050505050505050565b3360009081526020819052604090205460ff16611cdf5760405162461bcd60e51b815260040161028f9061354b565b600254604051633ec7d5b960e01b8152600760048201526001600160a01b03909116906000908290633ec7d5b990602401602060405180830381865afa158015611d2d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d51919061356e565b6040516340d5dc7f60e11b815260ff871660048201526001600160a01b0391909116906381abb8fe906024016040805180830381865afa158015611d99573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611dbd919061358b565b50604051633ec7d5b960e01b8152600660048201529091506001600160a01b03831690633ec7d5b990602401602060405180830381865afa158015611e06573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e2a919061356e565b604051637738515f60e01b81526001600160401b0388166004820152600060248201526001600160a01b039190911690637738515f90604401608060405180830381865afa158015611e80573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea49190613673565b5050604051633ec7d5b960e01b8152600c60048201526001600160a01b0385169250633ec7d5b99150602401602060405180830381865afa158015611eed573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f11919061356e565b604051631b4003ff60e11b81526001600160a01b038381166004830152898116602483015260448201869052919091169063368007fe90606401600060405180830381600087803b158015611f6557600080fd5b505af1158015611f79573d6000803e3d6000fd5b5050604051633ec7d5b960e01b8152600a60048201526001600160a01b0385169250633ec7d5b99150602401602060405180830381865afa158015611fc2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611fe6919061356e565b6040516293447560e61b81526001600160401b038816600482015260ff871660248201528515156044820152606481018590526001600160a01b0391909116906324d11d4090608401600060405180830381600087803b15801561204957600080fd5b505af115801561205d573d6000803e3d6000fd5b50506040805160ff891681526020810187905287151593506001600160401b038a1692506001600160a01b038b16917f544832b39fc44fc05cca7aa2c9f113bada9a6316b096b6cefcb302e433454a17910160405180910390a450505050505050565b600080826121355760408601516120da906283d600613893565b6001600160401b031686606001516001600160401b031610156121355760405162461bcd60e51b81526020600482015260136024820152721bdc99195c88191d5c881b195cdcc80c4c0c19606a1b604482015260640161028f565b600061214087612c27565b600254604051633ec7d5b960e01b8152600660048201529192506001600160a01b03169060009081908390633ec7d5b990602401602060405180830381865afa158015612191573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121b5919061356e565b60208b0151604051637738515f60e01b81526001600160401b039091166004820152600260248201526001600160a01b039190911690637738515f90604401608060405180830381865afa158015612211573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122359190613673565b506040516319045a2560e01b81529294509250506001600160a01b0383169073__$6230a6feddd2d01b0a9ffb5c5e188a1065$__906319045a25906122809088908d906004016138be565b602060405180830381865af415801561229d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122c1919061356e565b6001600160a01b0316146123065760405162461bcd60e51b815260206004820152600c60248201526b3839379039b4b3b71032b93960a11b604482015260640161028f565b604051633ec7d5b960e01b8152600660048201526000906001600160a01b03851690633ec7d5b990602401602060405180830381865afa15801561234e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612372919061356e565b8b51604051637738515f60e01b81526001600160401b039091166004820152600160248201526001600160a01b039190911690637738515f90604401608060405180830381865afa1580156123cb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123ef9190613673565b506040516319045a2560e01b81529295509250506001600160a01b0384169073__$6230a6feddd2d01b0a9ffb5c5e188a1065$__906319045a259061243a9089908f906004016138be565b602060405180830381865af4158015612457573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061247b919061356e565b6001600160a01b0316146124c15760405162461bcd60e51b815260206004820152600d60248201526c3ab9b2b91039b4b3b71032b93960991b604482015260640161028f565b806001600160401b0316826001600160401b0316146125115760405162461bcd60e51b815260206004820152600c60248201526b33b937bab8103234b33332b960a11b604482015260640161028f565b5090999098509650505050505050565b600254604051633ec7d5b960e01b8152600b60048201526000916001600160a01b03169082908290633ec7d5b990602401602060405180830381865afa15801561256f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612593919061356e565b6040516383889fe360e01b81526001600160401b03861660048201529091506001600160a01b038216906383889fe39060240160006040518083038186803b1580156125de57600080fd5b505afa1580156125f2573d6000803e3d6000fd5b505060405163494b14e960e11b81526001600160401b03871660048201526001600160a01b038416925063929629d29150602401602060405180830381865afa158015612643573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612667919061356e565b949350505050565b600254604051633ec7d5b960e01b8152600660048201526000918291829182916001600160a01b039091169082908290633ec7d5b990602401602060405180830381865afa1580156126c5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126e9919061356e565b905060005b8851816001600160401b03161015612947576001600160401b038116156127ad578861271b600183613705565b6001600160401b031681518110612734576127346138d7565b60200260200101516001600160401b031689826001600160401b031681518110612760576127606138d7565b60200260200101516001600160401b0316116127ad5760405162461bcd60e51b815260206004820152600c60248201526b35b4b73232bc32b99032b93960a11b604482015260640161028f565b816001600160a01b0316637738515f8a836001600160401b0316815181106127d7576127d76138d7565b60209081029190910101516040516001600160e01b031960e084901b1681526001600160401b03909116600482015260036024820152604401608060405180830381865afa15801561282d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128519190613673565b50919650909450506001600160401b03808516908c161480156129225750846001600160a01b03168a73__$6230a6feddd2d01b0a9ffb5c5e188a1065$__6319045a2590918b856001600160401b0316815181106128b1576128b16138d7565b60200260200101516040518363ffffffff1660e01b81526004016128d69291906138be565b602060405180830381865af41580156128f3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612917919061356e565b6001600160a01b0316145b15612935576129326001876138ed565b95505b8061293f81613912565b9150506126ee565b50604051633ec7d5b960e01b8152600b60048201526000906001600160a01b03841690633ec7d5b990602401602060405180830381865afa158015612990573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129b4919061356e565b6040516383889fe360e01b81526001600160401b038d1660048201529091506001600160a01b038216906383889fe39060240160006040518083038186803b1580156129ff57600080fd5b505afa158015612a13573d6000803e3d6000fd5b505060405163494b14e960e11b81526001600160401b038e1660048201526001600160a01b038416925063929629d29150602401602060405180830381865afa158015612a64573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a88919061356e565b604051630ee0c13560e31b81526001600160401b038d1660048201529095506001600160a01b0382169063770609a890602401602060405180830381865afa158015612ad8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612afc9190613938565b61ffff168660ff161015612b4a5760405162461bcd60e51b81526020600482015260156024820152741adcda59db8818db9d081b195cdcc819db195d995b605a1b604482015260640161028f565b6003856001600160a01b03166339f2db966040518163ffffffff1660e01b8152600401602060405180830381865afa158015612b8a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612bae91906136d2565b612bb99060016138ed565b612bc490600261395c565b612bce9190613985565b60ff168660ff161015612c185760405162461bcd60e51b81526020600482015260126024820152716b7369676e20636e74206c65737320322f3360701b604482015260640161028f565b50929998505050505050505050565b60008082608001516001600160401b031611612c775760405162461bcd60e51b815260206004820152600f60248201526e6f726465722073697a65207a65726f60881b604482015260640161028f565b60008260e0015111612cbf5760405162461bcd60e51b81526020600482015260116024820152706f7264657220737072696365207a65726f60781b604482015260640161028f565b6040820151612cd2906305265c00613893565b6001600160401b031682606001516001600160401b03161115612d375760405162461bcd60e51b815260206004820152601960248201527f6f7264657220647572206d6f7265207468616e20313030306400000000000000604482015260640161028f565b620151808260600151612d4a91906139a7565b6001600160401b031615612da05760405162461bcd60e51b815260206004820152601860248201527f6f7264657220656e64206e6f7420616c69676e20746f20640000000000000000604482015260640161028f565b4282604001516001600160401b031610612dfc5760405162461bcd60e51b815260206004820152601960248201527f6f72646572207374617274206d6f7265207468616e206e6f7700000000000000604482015260640161028f565b815160208084015160a08501516040808701516060880151608089015160c08a015160e08b01519451600099612e989990989796910160c098891b6001600160c01b0319908116825297891b8816600882015295881b8716601087015293871b8616601886015291861b8516602085015290941b909216602882015260f89290921b6001600160f81b0319166030830152603182015260510190565b60408051601f1981840301815291905280516020909101209392505050565b6001600160a01b0381168114612ecc57600080fd5b50565b600060208284031215612ee157600080fd5b8135612eec81612eb7565b9392505050565b634e487b7160e01b600052604160045260246000fd5b60405160a081016001600160401b0381118282101715612f2b57612f2b612ef3565b60405290565b604051608081016001600160401b0381118282101715612f2b57612f2b612ef3565b604051601f8201601f191681016001600160401b0381118282101715612f7b57612f7b612ef3565b604052919050565b6001600160401b0381168114612ecc57600080fd5b8035612fa381612f83565b919050565b60ff81168114612ecc57600080fd5b8035612fa381612fa8565b6000610100808385031215612fd657600080fd5b604051908101906001600160401b0382118183101715612ff857612ff8612ef3565b816040528092508335915061300c82612f83565b81815261301b60208501612f98565b602082015261302c60408501612f98565b604082015261303d60608501612f98565b606082015261304e60808501612f98565b608082015261305f60a08501612f98565b60a082015261307060c08501612fb7565b60c082015260e084013560e0820152505092915050565b600082601f83011261309857600080fd5b81356001600160401b038111156130b1576130b1612ef3565b6130c4601f8201601f1916602001612f53565b8181528460208386010111156130d957600080fd5b816020850160208301376000918101602001919091529392505050565b600080600080610160858703121561310d57600080fd5b843561311881612eb7565b93506131278660208701612fc2565b92506101208501356001600160401b038082111561314457600080fd5b61315088838901613087565b935061014087013591508082111561316757600080fd5b5061317487828801613087565b91505092959194509250565b8015158114612ecc57600080fd5b6000806000606084860312156131a357600080fd5b83356131ae81612eb7565b92506020848101356131bf81613180565b925060408501356001600160401b03808211156131db57600080fd5b818701915087601f8301126131ef57600080fd5b6131f7612f09565b8060a084018a81111561320957600080fd5b845b8181101561323d578035858111156132235760008081fd5b61322f8d828901613087565b85525092860192860161320b565b505080955050505050509250925092565b60006001600160401b0382111561326757613267612ef3565b5060051b60200190565b600082601f83011261328257600080fd5b813560206132976132928361324e565b612f53565b82815260059290921b840181019181810190868411156132b657600080fd5b8286015b848110156132da5780356132cd81612f83565b83529183019183016132ba565b509695505050505050565b600082601f8301126132f657600080fd5b813560206133066132928361324e565b82815260059290921b8401810191818101908684111561332557600080fd5b8286015b848110156132da5780356001600160401b038111156133485760008081fd5b6133568986838b0101613087565b845250918301918301613329565b60008060008084860360e081121561337b57600080fd5b853561338681612eb7565b94506080601f198201121561339a57600080fd5b506133a3612f31565b60208601356133b181612f83565b815260408601356133c181612fa8565b60208201526060868101356040830152608087013590820152925060a08501356001600160401b03808211156133f657600080fd5b61340288838901613271565b935060c087013591508082111561341857600080fd5b50613174878288016132e5565b6000806000806080858703121561343b57600080fd5b843561344681612eb7565b9350602085013561345681612f83565b9250604085013561346681612fa8565b9396929550929360600135925050565b600080600080610160858703121561348d57600080fd5b843561349881612eb7565b93506134a78660208701612fc2565b92506101208501356001600160401b03808211156134c457600080fd5b6134d088838901613271565b935061014087013591508082111561341857600080fd5b600080600080600060a086880312156134ff57600080fd5b853561350a81612eb7565b9450602086013561351a81612f83565b9350604086013561352a81612fa8565b9250606086013561353a81613180565b949793965091946080013592915050565b6020808252600990820152683737ba1037bbb732b960b91b604082015260600190565b60006020828403121561358057600080fd5b8151612eec81612eb7565b6000806040838503121561359e57600080fd5b82516135a981612eb7565b60208401519092506135ba81613180565b809150509250929050565b6001600160401b038082511683528060208301511660208401528060408301511660408401528060608301511660608401528060808301511660808401528060a08301511660a08401525060c081015161362460c084018260ff169052565b5060e090810151910152565b610120810161363f82856135c5565b6001600160401b0383166101008301529392505050565b60006020828403121561366857600080fd5b8151612eec81612f83565b6000806000806080858703121561368957600080fd5b845161369481612eb7565b60208601519094506136a581612eb7565b60408601519093506136b681612f83565b60608601519092506136c781612fa8565b939692955090935050565b6000602082840312156136e457600080fd5b8151612eec81612fa8565b634e487b7160e01b600052601160045260246000fd5b60006001600160401b0383811690831681811015613725576137256136ef565b039392505050565b6000816000190483118215151615613747576137476136ef565b500290565b634e487b7160e01b600052601260045260246000fd5b6000826137715761377161374c565b500490565b6000815180845260005b8181101561379c57602081850181015186830182015201613780565b818111156137ae576000602083870101525b50601f01601f19169290920160200192915050565b8281526040602080830182905260009160e084019190840185845b600581101561380d57603f198786030183526137fb858351613776565b945091830191908301906001016137de565b5092979650505050505050565b60006020828403121561382c57600080fd5b5051919050565b600082821015613845576138456136ef565b500390565b6000821982111561385d5761385d6136ef565b500190565b610140810161387182866135c5565b60ff84166101008301526001600160401b038316610120830152949350505050565b60006001600160401b038083168185168083038211156138b5576138b56136ef565b01949350505050565b8281526040602082015260006126676040830184613776565b634e487b7160e01b600052603260045260246000fd5b600060ff821660ff84168060ff0382111561390a5761390a6136ef565b019392505050565b60006001600160401b0380831681810361392e5761392e6136ef565b6001019392505050565b60006020828403121561394a57600080fd5b815161ffff81168114612eec57600080fd5b600060ff821660ff84168160ff048111821515161561397d5761397d6136ef565b029392505050565b600060ff8316806139985761399861374c565b8060ff84160491505092915050565b60006001600160401b03808416806139c1576139c161374c565b9216919091069291505056fea2646970667358221220a346e21a7ddeab432fee97ca40ba3d0e1fc89b9fe19e590ece68144d04d8353164736f6c634300080e0033"

// DeployControl2 deploys a new Ethereum contract, binding an instance of Control2 to it.
func DeployControl2(auth *bind.TransactOpts, backend bind.ContractBackend, _a common.Address, _inst common.Address) (common.Address, *types.Transaction, *Control2, error) {
	parsed, err := abi.JSON(strings.NewReader(Control2ABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	recoverAddr, _, _, _ := DeployRecover(auth, backend)
	Control2Bin = strings.Replace(Control2Bin, "__$6230a6feddd2d01b0a9ffb5c5e188a1065$__", recoverAddr.String()[2:], -1)

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(Control2Bin), backend, _a, _inst)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Control2{Control2Caller: Control2Caller{contract: contract}, Control2Transactor: Control2Transactor{contract: contract}, Control2Filterer: Control2Filterer{contract: contract}}, nil
}

// Control2 is an auto generated Go binding around an Ethereum contract.
type Control2 struct {
	Control2Caller     // Read-only binding to the contract
	Control2Transactor // Write-only binding to the contract
	Control2Filterer   // Log filterer for contract events
}

// Control2Caller is an auto generated read-only Go binding around an Ethereum contract.
type Control2Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// Control2Transactor is an auto generated write-only Go binding around an Ethereum contract.
type Control2Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// Control2Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type Control2Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// Control2Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type Control2Session struct {
	Contract     *Control2         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// Control2CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type Control2CallerSession struct {
	Contract *Control2Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// Control2TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type Control2TransactorSession struct {
	Contract     *Control2Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// Control2Raw is an auto generated low-level Go binding around an Ethereum contract.
type Control2Raw struct {
	Contract *Control2 // Generic contract binding to access the raw methods on
}

// Control2CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type Control2CallerRaw struct {
	Contract *Control2Caller // Generic read-only contract binding to access the raw methods on
}

// Control2TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type Control2TransactorRaw struct {
	Contract *Control2Transactor // Generic write-only contract binding to access the raw methods on
}

// NewControl2 creates a new instance of Control2, bound to a specific deployed contract.
func NewControl2(address common.Address, backend bind.ContractBackend) (*Control2, error) {
	contract, err := bindControl2(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Control2{Control2Caller: Control2Caller{contract: contract}, Control2Transactor: Control2Transactor{contract: contract}, Control2Filterer: Control2Filterer{contract: contract}}, nil
}

// NewControl2Caller creates a new read-only instance of Control2, bound to a specific deployed contract.
func NewControl2Caller(address common.Address, caller bind.ContractCaller) (*Control2Caller, error) {
	contract, err := bindControl2(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &Control2Caller{contract: contract}, nil
}

// NewControl2Transactor creates a new write-only instance of Control2, bound to a specific deployed contract.
func NewControl2Transactor(address common.Address, transactor bind.ContractTransactor) (*Control2Transactor, error) {
	contract, err := bindControl2(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &Control2Transactor{contract: contract}, nil
}

// NewControl2Filterer creates a new log filterer instance of Control2, bound to a specific deployed contract.
func NewControl2Filterer(address common.Address, filterer bind.ContractFilterer) (*Control2Filterer, error) {
	contract, err := bindControl2(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &Control2Filterer{contract: contract}, nil
}

// bindControl2 binds a generic wrapper to an already deployed contract.
func bindControl2(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(Control2ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Control2 *Control2Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Control2.Contract.Control2Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Control2 *Control2Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Control2.Contract.Control2Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Control2 *Control2Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Control2.Contract.Control2Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Control2 *Control2CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Control2.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Control2 *Control2TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Control2.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Control2 *Control2TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Control2.Contract.contract.Transact(opts, method, params...)
}

// Auth is a free data retrieval call binding the contract method 0xde9375f2.
//
// Solidity: function auth() view returns(address)
func (_Control2 *Control2Caller) Auth(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Control2.contract.Call(opts, &out, "auth")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Auth is a free data retrieval call binding the contract method 0xde9375f2.
//
// Solidity: function auth() view returns(address)
func (_Control2 *Control2Session) Auth() (common.Address, error) {
	return _Control2.Contract.Auth(&_Control2.CallOpts)
}

// Auth is a free data retrieval call binding the contract method 0xde9375f2.
//
// Solidity: function auth() view returns(address)
func (_Control2 *Control2CallerSession) Auth() (common.Address, error) {
	return _Control2.Contract.Auth(&_Control2.CallOpts)
}

// Inst is a free data retrieval call binding the contract method 0xbd6b2222.
//
// Solidity: function inst() view returns(address)
func (_Control2 *Control2Caller) Inst(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Control2.contract.Call(opts, &out, "inst")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Inst is a free data retrieval call binding the contract method 0xbd6b2222.
//
// Solidity: function inst() view returns(address)
func (_Control2 *Control2Session) Inst() (common.Address, error) {
	return _Control2.Contract.Inst(&_Control2.CallOpts)
}

// Inst is a free data retrieval call binding the contract method 0xbd6b2222.
//
// Solidity: function inst() view returns(address)
func (_Control2 *Control2CallerSession) Inst() (common.Address, error) {
	return _Control2.Contract.Inst(&_Control2.CallOpts)
}

// Owners is a free data retrieval call binding the contract method 0x022914a7.
//
// Solidity: function owners(address ) view returns(bool)
func (_Control2 *Control2Caller) Owners(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _Control2.contract.Call(opts, &out, "owners", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Owners is a free data retrieval call binding the contract method 0x022914a7.
//
// Solidity: function owners(address ) view returns(bool)
func (_Control2 *Control2Session) Owners(arg0 common.Address) (bool, error) {
	return _Control2.Contract.Owners(&_Control2.CallOpts, arg0)
}

// Owners is a free data retrieval call binding the contract method 0x022914a7.
//
// Solidity: function owners(address ) view returns(bool)
func (_Control2 *Control2CallerSession) Owners(arg0 common.Address) (bool, error) {
	return _Control2.Contract.Owners(&_Control2.CallOpts, arg0)
}

// Version is a free data retrieval call binding the contract method 0x54fd4d50.
//
// Solidity: function version() view returns(uint16)
func (_Control2 *Control2Caller) Version(opts *bind.CallOpts) (uint16, error) {
	var out []interface{}
	err := _Control2.contract.Call(opts, &out, "version")

	if err != nil {
		return *new(uint16), err
	}

	out0 := *abi.ConvertType(out[0], new(uint16)).(*uint16)

	return out0, err

}

// Version is a free data retrieval call binding the contract method 0x54fd4d50.
//
// Solidity: function version() view returns(uint16)
func (_Control2 *Control2Session) Version() (uint16, error) {
	return _Control2.Contract.Version(&_Control2.CallOpts)
}

// Version is a free data retrieval call binding the contract method 0x54fd4d50.
//
// Solidity: function version() view returns(uint16)
func (_Control2 *Control2CallerSession) Version() (uint16, error) {
	return _Control2.Contract.Version(&_Control2.CallOpts)
}

// Add is a paid mutator transaction binding the contract method 0x4bf1b134.
//
// Solidity: function add(address _a, bool isSet, bytes[5] signs) returns()
func (_Control2 *Control2Transactor) Add(opts *bind.TransactOpts, _a common.Address, isSet bool, signs [5][]byte) (*types.Transaction, error) {
	return _Control2.contract.Transact(opts, "add", _a, isSet, signs)
}

// Add is a paid mutator transaction binding the contract method 0x4bf1b134.
//
// Solidity: function add(address _a, bool isSet, bytes[5] signs) returns()
func (_Control2 *Control2Session) Add(_a common.Address, isSet bool, signs [5][]byte) (*types.Transaction, error) {
	return _Control2.Contract.Add(&_Control2.TransactOpts, _a, isSet, signs)
}

// Add is a paid mutator transaction binding the contract method 0x4bf1b134.
//
// Solidity: function add(address _a, bool isSet, bytes[5] signs) returns()
func (_Control2 *Control2TransactorSession) Add(_a common.Address, isSet bool, signs [5][]byte) (*types.Transaction, error) {
	return _Control2.Contract.Add(&_Control2.TransactOpts, _a, isSet, signs)
}

// AddOrder is a paid mutator transaction binding the contract method 0xae9d0b40.
//
// Solidity: function addOrder(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, bytes uSign, bytes pSign) returns()
func (_Control2 *Control2Transactor) AddOrder(opts *bind.TransactOpts, _a common.Address, ps OrderIn, uSign []byte, pSign []byte) (*types.Transaction, error) {
	return _Control2.contract.Transact(opts, "addOrder", _a, ps, uSign, pSign)
}

// AddOrder is a paid mutator transaction binding the contract method 0xae9d0b40.
//
// Solidity: function addOrder(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, bytes uSign, bytes pSign) returns()
func (_Control2 *Control2Session) AddOrder(_a common.Address, ps OrderIn, uSign []byte, pSign []byte) (*types.Transaction, error) {
	return _Control2.Contract.AddOrder(&_Control2.TransactOpts, _a, ps, uSign, pSign)
}

// AddOrder is a paid mutator transaction binding the contract method 0xae9d0b40.
//
// Solidity: function addOrder(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, bytes uSign, bytes pSign) returns()
func (_Control2 *Control2TransactorSession) AddOrder(_a common.Address, ps OrderIn, uSign []byte, pSign []byte) (*types.Transaction, error) {
	return _Control2.Contract.AddOrder(&_Control2.TransactOpts, _a, ps, uSign, pSign)
}

// AddRepair is a paid mutator transaction binding the contract method 0xaf99c59a.
//
// Solidity: function addRepair(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, uint64[] kIndexes, bytes[] ksigns) returns()
func (_Control2 *Control2Transactor) AddRepair(opts *bind.TransactOpts, _a common.Address, ps OrderIn, kIndexes []uint64, ksigns [][]byte) (*types.Transaction, error) {
	return _Control2.contract.Transact(opts, "addRepair", _a, ps, kIndexes, ksigns)
}

// AddRepair is a paid mutator transaction binding the contract method 0xaf99c59a.
//
// Solidity: function addRepair(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, uint64[] kIndexes, bytes[] ksigns) returns()
func (_Control2 *Control2Session) AddRepair(_a common.Address, ps OrderIn, kIndexes []uint64, ksigns [][]byte) (*types.Transaction, error) {
	return _Control2.Contract.AddRepair(&_Control2.TransactOpts, _a, ps, kIndexes, ksigns)
}

// AddRepair is a paid mutator transaction binding the contract method 0xaf99c59a.
//
// Solidity: function addRepair(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, uint64[] kIndexes, bytes[] ksigns) returns()
func (_Control2 *Control2TransactorSession) AddRepair(_a common.Address, ps OrderIn, kIndexes []uint64, ksigns [][]byte) (*types.Transaction, error) {
	return _Control2.Contract.AddRepair(&_Control2.TransactOpts, _a, ps, kIndexes, ksigns)
}

// ProWithdraw is a paid mutator transaction binding the contract method 0x54aa6642.
//
// Solidity: function proWithdraw(address _a, (uint64,uint8,uint256,uint256) ps, uint64[] kIndexes, bytes[] ksigns) returns()
func (_Control2 *Control2Transactor) ProWithdraw(opts *bind.TransactOpts, _a common.Address, ps PWIn, kIndexes []uint64, ksigns [][]byte) (*types.Transaction, error) {
	return _Control2.contract.Transact(opts, "proWithdraw", _a, ps, kIndexes, ksigns)
}

// ProWithdraw is a paid mutator transaction binding the contract method 0x54aa6642.
//
// Solidity: function proWithdraw(address _a, (uint64,uint8,uint256,uint256) ps, uint64[] kIndexes, bytes[] ksigns) returns()
func (_Control2 *Control2Session) ProWithdraw(_a common.Address, ps PWIn, kIndexes []uint64, ksigns [][]byte) (*types.Transaction, error) {
	return _Control2.Contract.ProWithdraw(&_Control2.TransactOpts, _a, ps, kIndexes, ksigns)
}

// ProWithdraw is a paid mutator transaction binding the contract method 0x54aa6642.
//
// Solidity: function proWithdraw(address _a, (uint64,uint8,uint256,uint256) ps, uint64[] kIndexes, bytes[] ksigns) returns()
func (_Control2 *Control2TransactorSession) ProWithdraw(_a common.Address, ps PWIn, kIndexes []uint64, ksigns [][]byte) (*types.Transaction, error) {
	return _Control2.Contract.ProWithdraw(&_Control2.TransactOpts, _a, ps, kIndexes, ksigns)
}

// Recharge is a paid mutator transaction binding the contract method 0xf661f9e3.
//
// Solidity: function recharge(address _a, uint64 _ui, uint8 _ti, bool isLock, uint256 money) returns()
func (_Control2 *Control2Transactor) Recharge(opts *bind.TransactOpts, _a common.Address, _ui uint64, _ti uint8, isLock bool, money *big.Int) (*types.Transaction, error) {
	return _Control2.contract.Transact(opts, "recharge", _a, _ui, _ti, isLock, money)
}

// Recharge is a paid mutator transaction binding the contract method 0xf661f9e3.
//
// Solidity: function recharge(address _a, uint64 _ui, uint8 _ti, bool isLock, uint256 money) returns()
func (_Control2 *Control2Session) Recharge(_a common.Address, _ui uint64, _ti uint8, isLock bool, money *big.Int) (*types.Transaction, error) {
	return _Control2.Contract.Recharge(&_Control2.TransactOpts, _a, _ui, _ti, isLock, money)
}

// Recharge is a paid mutator transaction binding the contract method 0xf661f9e3.
//
// Solidity: function recharge(address _a, uint64 _ui, uint8 _ti, bool isLock, uint256 money) returns()
func (_Control2 *Control2TransactorSession) Recharge(_a common.Address, _ui uint64, _ti uint8, isLock bool, money *big.Int) (*types.Transaction, error) {
	return _Control2.Contract.Recharge(&_Control2.TransactOpts, _a, _ui, _ti, isLock, money)
}

// SubOrder is a paid mutator transaction binding the contract method 0x42f45166.
//
// Solidity: function subOrder(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, bytes uSign, bytes pSign) returns()
func (_Control2 *Control2Transactor) SubOrder(opts *bind.TransactOpts, _a common.Address, ps OrderIn, uSign []byte, pSign []byte) (*types.Transaction, error) {
	return _Control2.contract.Transact(opts, "subOrder", _a, ps, uSign, pSign)
}

// SubOrder is a paid mutator transaction binding the contract method 0x42f45166.
//
// Solidity: function subOrder(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, bytes uSign, bytes pSign) returns()
func (_Control2 *Control2Session) SubOrder(_a common.Address, ps OrderIn, uSign []byte, pSign []byte) (*types.Transaction, error) {
	return _Control2.Contract.SubOrder(&_Control2.TransactOpts, _a, ps, uSign, pSign)
}

// SubOrder is a paid mutator transaction binding the contract method 0x42f45166.
//
// Solidity: function subOrder(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, bytes uSign, bytes pSign) returns()
func (_Control2 *Control2TransactorSession) SubOrder(_a common.Address, ps OrderIn, uSign []byte, pSign []byte) (*types.Transaction, error) {
	return _Control2.Contract.SubOrder(&_Control2.TransactOpts, _a, ps, uSign, pSign)
}

// Withdraw is a paid mutator transaction binding the contract method 0x9b4c757a.
//
// Solidity: function withdraw(address _a, uint64 _i, uint8 _ti, uint256 money) returns()
func (_Control2 *Control2Transactor) Withdraw(opts *bind.TransactOpts, _a common.Address, _i uint64, _ti uint8, money *big.Int) (*types.Transaction, error) {
	return _Control2.contract.Transact(opts, "withdraw", _a, _i, _ti, money)
}

// Withdraw is a paid mutator transaction binding the contract method 0x9b4c757a.
//
// Solidity: function withdraw(address _a, uint64 _i, uint8 _ti, uint256 money) returns()
func (_Control2 *Control2Session) Withdraw(_a common.Address, _i uint64, _ti uint8, money *big.Int) (*types.Transaction, error) {
	return _Control2.Contract.Withdraw(&_Control2.TransactOpts, _a, _i, _ti, money)
}

// Withdraw is a paid mutator transaction binding the contract method 0x9b4c757a.
//
// Solidity: function withdraw(address _a, uint64 _i, uint8 _ti, uint256 money) returns()
func (_Control2 *Control2TransactorSession) Withdraw(_a common.Address, _i uint64, _ti uint8, money *big.Int) (*types.Transaction, error) {
	return _Control2.Contract.Withdraw(&_Control2.TransactOpts, _a, _i, _ti, money)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_Control2 *Control2Transactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Control2.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_Control2 *Control2Session) Receive() (*types.Transaction, error) {
	return _Control2.Contract.Receive(&_Control2.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_Control2 *Control2TransactorSession) Receive() (*types.Transaction, error) {
	return _Control2.Contract.Receive(&_Control2.TransactOpts)
}

// Control2AddOwnerIterator is returned from FilterAddOwner and is used to iterate over the raw logs and unpacked data for AddOwner events raised by the Control2 contract.
type Control2AddOwnerIterator struct {
	Event *Control2AddOwner // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *Control2AddOwnerIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(Control2AddOwner)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(Control2AddOwner)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *Control2AddOwnerIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *Control2AddOwnerIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// Control2AddOwner represents a AddOwner event raised by the Control2 contract.
type Control2AddOwner struct {
	From  common.Address
	IsSet bool
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterAddOwner is a free log retrieval operation binding the contract event 0x938b2a24c98e4e542127ffa74a91e48942c2bddccae3b6d75f82bfda7bbc0807.
//
// Solidity: event AddOwner(address from, bool isSet)
func (_Control2 *Control2Filterer) FilterAddOwner(opts *bind.FilterOpts) (*Control2AddOwnerIterator, error) {

	logs, sub, err := _Control2.contract.FilterLogs(opts, "AddOwner")
	if err != nil {
		return nil, err
	}
	return &Control2AddOwnerIterator{contract: _Control2.contract, event: "AddOwner", logs: logs, sub: sub}, nil
}

// WatchAddOwner is a free log subscription operation binding the contract event 0x938b2a24c98e4e542127ffa74a91e48942c2bddccae3b6d75f82bfda7bbc0807.
//
// Solidity: event AddOwner(address from, bool isSet)
func (_Control2 *Control2Filterer) WatchAddOwner(opts *bind.WatchOpts, sink chan<- *Control2AddOwner) (event.Subscription, error) {

	logs, sub, err := _Control2.contract.WatchLogs(opts, "AddOwner")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(Control2AddOwner)
				if err := _Control2.contract.UnpackLog(event, "AddOwner", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddOwner is a log parse operation binding the contract event 0x938b2a24c98e4e542127ffa74a91e48942c2bddccae3b6d75f82bfda7bbc0807.
//
// Solidity: event AddOwner(address from, bool isSet)
func (_Control2 *Control2Filterer) ParseAddOwner(log types.Log) (*Control2AddOwner, error) {
	event := new(Control2AddOwner)
	if err := _Control2.contract.UnpackLog(event, "AddOwner", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// Control2ProWithdrawIterator is returned from FilterProWithdraw and is used to iterate over the raw logs and unpacked data for ProWithdraw events raised by the Control2 contract.
type Control2ProWithdrawIterator struct {
	Event *Control2ProWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *Control2ProWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(Control2ProWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(Control2ProWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *Control2ProWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *Control2ProWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// Control2ProWithdraw represents a ProWithdraw event raised by the Control2 contract.
type Control2ProWithdraw struct {
	A    common.Address
	Pi   uint64
	Ti   uint8
	Pay  *big.Int
	Lost *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterProWithdraw is a free log retrieval operation binding the contract event 0x3ea20fac35aae529e59d08cd5e2b0481108ccd275b50215084c05039245766db.
//
// Solidity: event ProWithdraw(address indexed a, uint64 indexed pi, uint8 ti, uint256 pay, uint256 lost)
func (_Control2 *Control2Filterer) FilterProWithdraw(opts *bind.FilterOpts, a []common.Address, pi []uint64) (*Control2ProWithdrawIterator, error) {

	var aRule []interface{}
	for _, aItem := range a {
		aRule = append(aRule, aItem)
	}
	var piRule []interface{}
	for _, piItem := range pi {
		piRule = append(piRule, piItem)
	}

	logs, sub, err := _Control2.contract.FilterLogs(opts, "ProWithdraw", aRule, piRule)
	if err != nil {
		return nil, err
	}
	return &Control2ProWithdrawIterator{contract: _Control2.contract, event: "ProWithdraw", logs: logs, sub: sub}, nil
}

// WatchProWithdraw is a free log subscription operation binding the contract event 0x3ea20fac35aae529e59d08cd5e2b0481108ccd275b50215084c05039245766db.
//
// Solidity: event ProWithdraw(address indexed a, uint64 indexed pi, uint8 ti, uint256 pay, uint256 lost)
func (_Control2 *Control2Filterer) WatchProWithdraw(opts *bind.WatchOpts, sink chan<- *Control2ProWithdraw, a []common.Address, pi []uint64) (event.Subscription, error) {

	var aRule []interface{}
	for _, aItem := range a {
		aRule = append(aRule, aItem)
	}
	var piRule []interface{}
	for _, piItem := range pi {
		piRule = append(piRule, piItem)
	}

	logs, sub, err := _Control2.contract.WatchLogs(opts, "ProWithdraw", aRule, piRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(Control2ProWithdraw)
				if err := _Control2.contract.UnpackLog(event, "ProWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProWithdraw is a log parse operation binding the contract event 0x3ea20fac35aae529e59d08cd5e2b0481108ccd275b50215084c05039245766db.
//
// Solidity: event ProWithdraw(address indexed a, uint64 indexed pi, uint8 ti, uint256 pay, uint256 lost)
func (_Control2 *Control2Filterer) ParseProWithdraw(log types.Log) (*Control2ProWithdraw, error) {
	event := new(Control2ProWithdraw)
	if err := _Control2.contract.UnpackLog(event, "ProWithdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// Control2RechargeIterator is returned from FilterRecharge and is used to iterate over the raw logs and unpacked data for Recharge events raised by the Control2 contract.
type Control2RechargeIterator struct {
	Event *Control2Recharge // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *Control2RechargeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(Control2Recharge)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(Control2Recharge)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *Control2RechargeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *Control2RechargeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// Control2Recharge represents a Recharge event raised by the Control2 contract.
type Control2Recharge struct {
	Payer  common.Address
	I      uint64
	IsLock bool
	Ti     uint8
	Money  *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRecharge is a free log retrieval operation binding the contract event 0x544832b39fc44fc05cca7aa2c9f113bada9a6316b096b6cefcb302e433454a17.
//
// Solidity: event Recharge(address indexed payer, uint64 indexed i, bool indexed isLock, uint8 ti, uint256 money)
func (_Control2 *Control2Filterer) FilterRecharge(opts *bind.FilterOpts, payer []common.Address, i []uint64, isLock []bool) (*Control2RechargeIterator, error) {

	var payerRule []interface{}
	for _, payerItem := range payer {
		payerRule = append(payerRule, payerItem)
	}
	var iRule []interface{}
	for _, iItem := range i {
		iRule = append(iRule, iItem)
	}
	var isLockRule []interface{}
	for _, isLockItem := range isLock {
		isLockRule = append(isLockRule, isLockItem)
	}

	logs, sub, err := _Control2.contract.FilterLogs(opts, "Recharge", payerRule, iRule, isLockRule)
	if err != nil {
		return nil, err
	}
	return &Control2RechargeIterator{contract: _Control2.contract, event: "Recharge", logs: logs, sub: sub}, nil
}

// WatchRecharge is a free log subscription operation binding the contract event 0x544832b39fc44fc05cca7aa2c9f113bada9a6316b096b6cefcb302e433454a17.
//
// Solidity: event Recharge(address indexed payer, uint64 indexed i, bool indexed isLock, uint8 ti, uint256 money)
func (_Control2 *Control2Filterer) WatchRecharge(opts *bind.WatchOpts, sink chan<- *Control2Recharge, payer []common.Address, i []uint64, isLock []bool) (event.Subscription, error) {

	var payerRule []interface{}
	for _, payerItem := range payer {
		payerRule = append(payerRule, payerItem)
	}
	var iRule []interface{}
	for _, iItem := range i {
		iRule = append(iRule, iItem)
	}
	var isLockRule []interface{}
	for _, isLockItem := range isLock {
		isLockRule = append(isLockRule, isLockItem)
	}

	logs, sub, err := _Control2.contract.WatchLogs(opts, "Recharge", payerRule, iRule, isLockRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(Control2Recharge)
				if err := _Control2.contract.UnpackLog(event, "Recharge", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRecharge is a log parse operation binding the contract event 0x544832b39fc44fc05cca7aa2c9f113bada9a6316b096b6cefcb302e433454a17.
//
// Solidity: event Recharge(address indexed payer, uint64 indexed i, bool indexed isLock, uint8 ti, uint256 money)
func (_Control2 *Control2Filterer) ParseRecharge(log types.Log) (*Control2Recharge, error) {
	event := new(Control2Recharge)
	if err := _Control2.contract.UnpackLog(event, "Recharge", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// Control2WithdrawIterator is returned from FilterWithdraw and is used to iterate over the raw logs and unpacked data for Withdraw events raised by the Control2 contract.
type Control2WithdrawIterator struct {
	Event *Control2Withdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *Control2WithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(Control2Withdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(Control2Withdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *Control2WithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *Control2WithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// Control2Withdraw represents a Withdraw event raised by the Control2 contract.
type Control2Withdraw struct {
	Addr        common.Address
	I           uint64
	Ti          uint8
	Money       *big.Int
	ActualMoney *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterWithdraw is a free log retrieval operation binding the contract event 0x8cf9f6665801a7a41feb765d72a4472b5f7d327ed18c77c6e81d2bb5622cd8c0.
//
// Solidity: event Withdraw(address indexed addr, uint64 indexed i, uint8 ti, uint256 money, uint256 actualMoney)
func (_Control2 *Control2Filterer) FilterWithdraw(opts *bind.FilterOpts, addr []common.Address, i []uint64) (*Control2WithdrawIterator, error) {

	var addrRule []interface{}
	for _, addrItem := range addr {
		addrRule = append(addrRule, addrItem)
	}
	var iRule []interface{}
	for _, iItem := range i {
		iRule = append(iRule, iItem)
	}

	logs, sub, err := _Control2.contract.FilterLogs(opts, "Withdraw", addrRule, iRule)
	if err != nil {
		return nil, err
	}
	return &Control2WithdrawIterator{contract: _Control2.contract, event: "Withdraw", logs: logs, sub: sub}, nil
}

// WatchWithdraw is a free log subscription operation binding the contract event 0x8cf9f6665801a7a41feb765d72a4472b5f7d327ed18c77c6e81d2bb5622cd8c0.
//
// Solidity: event Withdraw(address indexed addr, uint64 indexed i, uint8 ti, uint256 money, uint256 actualMoney)
func (_Control2 *Control2Filterer) WatchWithdraw(opts *bind.WatchOpts, sink chan<- *Control2Withdraw, addr []common.Address, i []uint64) (event.Subscription, error) {

	var addrRule []interface{}
	for _, addrItem := range addr {
		addrRule = append(addrRule, addrItem)
	}
	var iRule []interface{}
	for _, iItem := range i {
		iRule = append(iRule, iItem)
	}

	logs, sub, err := _Control2.contract.WatchLogs(opts, "Withdraw", addrRule, iRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(Control2Withdraw)
				if err := _Control2.contract.UnpackLog(event, "Withdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdraw is a log parse operation binding the contract event 0x8cf9f6665801a7a41feb765d72a4472b5f7d327ed18c77c6e81d2bb5622cd8c0.
//
// Solidity: event Withdraw(address indexed addr, uint64 indexed i, uint8 ti, uint256 money, uint256 actualMoney)
func (_Control2 *Control2Filterer) ParseWithdraw(log types.Log) (*Control2Withdraw, error) {
	event := new(Control2Withdraw)
	if err := _Control2.contract.UnpackLog(event, "Withdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAuthABI is the input ABI used to generate the binding from.
const IAuthABI = "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_h\",\"type\":\"bytes32\"},{\"internalType\":\"bytes[5]\",\"name\":\"signs\",\"type\":\"bytes[5]\"}],\"name\":\"perm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IAuthFuncSigs maps the 4-byte function signature to its string representation.
var IAuthFuncSigs = map[string]string{
	"a96bba9d": "perm(bytes32,bytes[5])",
}

// IAuth is an auto generated Go binding around an Ethereum contract.
type IAuth struct {
	IAuthCaller     // Read-only binding to the contract
	IAuthTransactor // Write-only binding to the contract
	IAuthFilterer   // Log filterer for contract events
}

// IAuthCaller is an auto generated read-only Go binding around an Ethereum contract.
type IAuthCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuthTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IAuthTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuthFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IAuthFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAuthSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IAuthSession struct {
	Contract     *IAuth            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IAuthCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IAuthCallerSession struct {
	Contract *IAuthCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IAuthTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IAuthTransactorSession struct {
	Contract     *IAuthTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IAuthRaw is an auto generated low-level Go binding around an Ethereum contract.
type IAuthRaw struct {
	Contract *IAuth // Generic contract binding to access the raw methods on
}

// IAuthCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IAuthCallerRaw struct {
	Contract *IAuthCaller // Generic read-only contract binding to access the raw methods on
}

// IAuthTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IAuthTransactorRaw struct {
	Contract *IAuthTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIAuth creates a new instance of IAuth, bound to a specific deployed contract.
func NewIAuth(address common.Address, backend bind.ContractBackend) (*IAuth, error) {
	contract, err := bindIAuth(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IAuth{IAuthCaller: IAuthCaller{contract: contract}, IAuthTransactor: IAuthTransactor{contract: contract}, IAuthFilterer: IAuthFilterer{contract: contract}}, nil
}

// NewIAuthCaller creates a new read-only instance of IAuth, bound to a specific deployed contract.
func NewIAuthCaller(address common.Address, caller bind.ContractCaller) (*IAuthCaller, error) {
	contract, err := bindIAuth(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IAuthCaller{contract: contract}, nil
}

// NewIAuthTransactor creates a new write-only instance of IAuth, bound to a specific deployed contract.
func NewIAuthTransactor(address common.Address, transactor bind.ContractTransactor) (*IAuthTransactor, error) {
	contract, err := bindIAuth(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IAuthTransactor{contract: contract}, nil
}

// NewIAuthFilterer creates a new log filterer instance of IAuth, bound to a specific deployed contract.
func NewIAuthFilterer(address common.Address, filterer bind.ContractFilterer) (*IAuthFilterer, error) {
	contract, err := bindIAuth(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IAuthFilterer{contract: contract}, nil
}

// bindIAuth binds a generic wrapper to an already deployed contract.
func bindIAuth(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IAuthABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAuth *IAuthRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAuth.Contract.IAuthCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAuth *IAuthRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuth.Contract.IAuthTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAuth *IAuthRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAuth.Contract.IAuthTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAuth *IAuthCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAuth.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAuth *IAuthTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAuth.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAuth *IAuthTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAuth.Contract.contract.Transact(opts, method, params...)
}

// Perm is a paid mutator transaction binding the contract method 0xa96bba9d.
//
// Solidity: function perm(bytes32 _h, bytes[5] signs) returns()
func (_IAuth *IAuthTransactor) Perm(opts *bind.TransactOpts, _h [32]byte, signs [5][]byte) (*types.Transaction, error) {
	return _IAuth.contract.Transact(opts, "perm", _h, signs)
}

// Perm is a paid mutator transaction binding the contract method 0xa96bba9d.
//
// Solidity: function perm(bytes32 _h, bytes[5] signs) returns()
func (_IAuth *IAuthSession) Perm(_h [32]byte, signs [5][]byte) (*types.Transaction, error) {
	return _IAuth.Contract.Perm(&_IAuth.TransactOpts, _h, signs)
}

// Perm is a paid mutator transaction binding the contract method 0xa96bba9d.
//
// Solidity: function perm(bytes32 _h, bytes[5] signs) returns()
func (_IAuth *IAuthTransactorSession) Perm(_h [32]byte, signs [5][]byte) (*types.Transaction, error) {
	return _IAuth.Contract.Perm(&_IAuth.TransactOpts, _h, signs)
}

// IControl2ABI is the input ABI used to generate the binding from.
const IControl2ABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"pi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ti\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lost\",\"type\":\"uint256\"}],\"name\":\"ProWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"i\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isLock\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ti\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"Recharge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"i\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ti\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualMoney\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"uIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"pIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"size\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"tIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"sprice\",\"type\":\"uint256\"}],\"internalType\":\"structOrderIn\",\"name\":\"_oi\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"uSign\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"pSign\",\"type\":\"bytes\"}],\"name\":\"addOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"uIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"pIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"size\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"tIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"sprice\",\"type\":\"uint256\"}],\"internalType\":\"structOrderIn\",\"name\":\"_oi\",\"type\":\"tuple\"},{\"internalType\":\"uint64[]\",\"name\":\"_kis\",\"type\":\"uint64[]\"},{\"internalType\":\"bytes[]\",\"name\":\"ksigns\",\"type\":\"bytes[]\"}],\"name\":\"addRepair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"pIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"tIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"pay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lost\",\"type\":\"uint256\"}],\"internalType\":\"structPWIn\",\"name\":\"_ps\",\"type\":\"tuple\"},{\"internalType\":\"uint64[]\",\"name\":\"_kis\",\"type\":\"uint64[]\"},{\"internalType\":\"bytes[]\",\"name\":\"ksigns\",\"type\":\"bytes[]\"}],\"name\":\"proWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_i\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isLock\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_money\",\"type\":\"uint256\"}],\"name\":\"recharge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"uIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"pIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"size\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"tIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"sprice\",\"type\":\"uint256\"}],\"internalType\":\"structOrderIn\",\"name\":\"_oi\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"uSign\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"pSign\",\"type\":\"bytes\"}],\"name\":\"subOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_i\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_money\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IControl2FuncSigs maps the 4-byte function signature to its string representation.
var IControl2FuncSigs = map[string]string{
	"ae9d0b40": "addOrder(address,(uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256),bytes,bytes)",
	"af99c59a": "addRepair(address,(uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256),uint64[],bytes[])",
	"54aa6642": "proWithdraw(address,(uint64,uint8,uint256,uint256),uint64[],bytes[])",
	"f661f9e3": "recharge(address,uint64,uint8,bool,uint256)",
	"42f45166": "subOrder(address,(uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256),bytes,bytes)",
	"9b4c757a": "withdraw(address,uint64,uint8,uint256)",
}

// IControl2 is an auto generated Go binding around an Ethereum contract.
type IControl2 struct {
	IControl2Caller     // Read-only binding to the contract
	IControl2Transactor // Write-only binding to the contract
	IControl2Filterer   // Log filterer for contract events
}

// IControl2Caller is an auto generated read-only Go binding around an Ethereum contract.
type IControl2Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IControl2Transactor is an auto generated write-only Go binding around an Ethereum contract.
type IControl2Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IControl2Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IControl2Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IControl2Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IControl2Session struct {
	Contract     *IControl2        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IControl2CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IControl2CallerSession struct {
	Contract *IControl2Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// IControl2TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IControl2TransactorSession struct {
	Contract     *IControl2Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// IControl2Raw is an auto generated low-level Go binding around an Ethereum contract.
type IControl2Raw struct {
	Contract *IControl2 // Generic contract binding to access the raw methods on
}

// IControl2CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IControl2CallerRaw struct {
	Contract *IControl2Caller // Generic read-only contract binding to access the raw methods on
}

// IControl2TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IControl2TransactorRaw struct {
	Contract *IControl2Transactor // Generic write-only contract binding to access the raw methods on
}

// NewIControl2 creates a new instance of IControl2, bound to a specific deployed contract.
func NewIControl2(address common.Address, backend bind.ContractBackend) (*IControl2, error) {
	contract, err := bindIControl2(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IControl2{IControl2Caller: IControl2Caller{contract: contract}, IControl2Transactor: IControl2Transactor{contract: contract}, IControl2Filterer: IControl2Filterer{contract: contract}}, nil
}

// NewIControl2Caller creates a new read-only instance of IControl2, bound to a specific deployed contract.
func NewIControl2Caller(address common.Address, caller bind.ContractCaller) (*IControl2Caller, error) {
	contract, err := bindIControl2(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IControl2Caller{contract: contract}, nil
}

// NewIControl2Transactor creates a new write-only instance of IControl2, bound to a specific deployed contract.
func NewIControl2Transactor(address common.Address, transactor bind.ContractTransactor) (*IControl2Transactor, error) {
	contract, err := bindIControl2(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IControl2Transactor{contract: contract}, nil
}

// NewIControl2Filterer creates a new log filterer instance of IControl2, bound to a specific deployed contract.
func NewIControl2Filterer(address common.Address, filterer bind.ContractFilterer) (*IControl2Filterer, error) {
	contract, err := bindIControl2(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IControl2Filterer{contract: contract}, nil
}

// bindIControl2 binds a generic wrapper to an already deployed contract.
func bindIControl2(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IControl2ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IControl2 *IControl2Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IControl2.Contract.IControl2Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IControl2 *IControl2Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IControl2.Contract.IControl2Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IControl2 *IControl2Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IControl2.Contract.IControl2Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IControl2 *IControl2CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IControl2.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IControl2 *IControl2TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IControl2.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IControl2 *IControl2TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IControl2.Contract.contract.Transact(opts, method, params...)
}

// AddOrder is a paid mutator transaction binding the contract method 0xae9d0b40.
//
// Solidity: function addOrder(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) _oi, bytes uSign, bytes pSign) returns()
func (_IControl2 *IControl2Transactor) AddOrder(opts *bind.TransactOpts, _a common.Address, _oi OrderIn, uSign []byte, pSign []byte) (*types.Transaction, error) {
	return _IControl2.contract.Transact(opts, "addOrder", _a, _oi, uSign, pSign)
}

// AddOrder is a paid mutator transaction binding the contract method 0xae9d0b40.
//
// Solidity: function addOrder(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) _oi, bytes uSign, bytes pSign) returns()
func (_IControl2 *IControl2Session) AddOrder(_a common.Address, _oi OrderIn, uSign []byte, pSign []byte) (*types.Transaction, error) {
	return _IControl2.Contract.AddOrder(&_IControl2.TransactOpts, _a, _oi, uSign, pSign)
}

// AddOrder is a paid mutator transaction binding the contract method 0xae9d0b40.
//
// Solidity: function addOrder(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) _oi, bytes uSign, bytes pSign) returns()
func (_IControl2 *IControl2TransactorSession) AddOrder(_a common.Address, _oi OrderIn, uSign []byte, pSign []byte) (*types.Transaction, error) {
	return _IControl2.Contract.AddOrder(&_IControl2.TransactOpts, _a, _oi, uSign, pSign)
}

// AddRepair is a paid mutator transaction binding the contract method 0xaf99c59a.
//
// Solidity: function addRepair(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) _oi, uint64[] _kis, bytes[] ksigns) returns()
func (_IControl2 *IControl2Transactor) AddRepair(opts *bind.TransactOpts, _a common.Address, _oi OrderIn, _kis []uint64, ksigns [][]byte) (*types.Transaction, error) {
	return _IControl2.contract.Transact(opts, "addRepair", _a, _oi, _kis, ksigns)
}

// AddRepair is a paid mutator transaction binding the contract method 0xaf99c59a.
//
// Solidity: function addRepair(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) _oi, uint64[] _kis, bytes[] ksigns) returns()
func (_IControl2 *IControl2Session) AddRepair(_a common.Address, _oi OrderIn, _kis []uint64, ksigns [][]byte) (*types.Transaction, error) {
	return _IControl2.Contract.AddRepair(&_IControl2.TransactOpts, _a, _oi, _kis, ksigns)
}

// AddRepair is a paid mutator transaction binding the contract method 0xaf99c59a.
//
// Solidity: function addRepair(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) _oi, uint64[] _kis, bytes[] ksigns) returns()
func (_IControl2 *IControl2TransactorSession) AddRepair(_a common.Address, _oi OrderIn, _kis []uint64, ksigns [][]byte) (*types.Transaction, error) {
	return _IControl2.Contract.AddRepair(&_IControl2.TransactOpts, _a, _oi, _kis, ksigns)
}

// ProWithdraw is a paid mutator transaction binding the contract method 0x54aa6642.
//
// Solidity: function proWithdraw(address _a, (uint64,uint8,uint256,uint256) _ps, uint64[] _kis, bytes[] ksigns) returns()
func (_IControl2 *IControl2Transactor) ProWithdraw(opts *bind.TransactOpts, _a common.Address, _ps PWIn, _kis []uint64, ksigns [][]byte) (*types.Transaction, error) {
	return _IControl2.contract.Transact(opts, "proWithdraw", _a, _ps, _kis, ksigns)
}

// ProWithdraw is a paid mutator transaction binding the contract method 0x54aa6642.
//
// Solidity: function proWithdraw(address _a, (uint64,uint8,uint256,uint256) _ps, uint64[] _kis, bytes[] ksigns) returns()
func (_IControl2 *IControl2Session) ProWithdraw(_a common.Address, _ps PWIn, _kis []uint64, ksigns [][]byte) (*types.Transaction, error) {
	return _IControl2.Contract.ProWithdraw(&_IControl2.TransactOpts, _a, _ps, _kis, ksigns)
}

// ProWithdraw is a paid mutator transaction binding the contract method 0x54aa6642.
//
// Solidity: function proWithdraw(address _a, (uint64,uint8,uint256,uint256) _ps, uint64[] _kis, bytes[] ksigns) returns()
func (_IControl2 *IControl2TransactorSession) ProWithdraw(_a common.Address, _ps PWIn, _kis []uint64, ksigns [][]byte) (*types.Transaction, error) {
	return _IControl2.Contract.ProWithdraw(&_IControl2.TransactOpts, _a, _ps, _kis, ksigns)
}

// Recharge is a paid mutator transaction binding the contract method 0xf661f9e3.
//
// Solidity: function recharge(address _a, uint64 _i, uint8 _ti, bool isLock, uint256 _money) returns()
func (_IControl2 *IControl2Transactor) Recharge(opts *bind.TransactOpts, _a common.Address, _i uint64, _ti uint8, isLock bool, _money *big.Int) (*types.Transaction, error) {
	return _IControl2.contract.Transact(opts, "recharge", _a, _i, _ti, isLock, _money)
}

// Recharge is a paid mutator transaction binding the contract method 0xf661f9e3.
//
// Solidity: function recharge(address _a, uint64 _i, uint8 _ti, bool isLock, uint256 _money) returns()
func (_IControl2 *IControl2Session) Recharge(_a common.Address, _i uint64, _ti uint8, isLock bool, _money *big.Int) (*types.Transaction, error) {
	return _IControl2.Contract.Recharge(&_IControl2.TransactOpts, _a, _i, _ti, isLock, _money)
}

// Recharge is a paid mutator transaction binding the contract method 0xf661f9e3.
//
// Solidity: function recharge(address _a, uint64 _i, uint8 _ti, bool isLock, uint256 _money) returns()
func (_IControl2 *IControl2TransactorSession) Recharge(_a common.Address, _i uint64, _ti uint8, isLock bool, _money *big.Int) (*types.Transaction, error) {
	return _IControl2.Contract.Recharge(&_IControl2.TransactOpts, _a, _i, _ti, isLock, _money)
}

// SubOrder is a paid mutator transaction binding the contract method 0x42f45166.
//
// Solidity: function subOrder(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) _oi, bytes uSign, bytes pSign) returns()
func (_IControl2 *IControl2Transactor) SubOrder(opts *bind.TransactOpts, _a common.Address, _oi OrderIn, uSign []byte, pSign []byte) (*types.Transaction, error) {
	return _IControl2.contract.Transact(opts, "subOrder", _a, _oi, uSign, pSign)
}

// SubOrder is a paid mutator transaction binding the contract method 0x42f45166.
//
// Solidity: function subOrder(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) _oi, bytes uSign, bytes pSign) returns()
func (_IControl2 *IControl2Session) SubOrder(_a common.Address, _oi OrderIn, uSign []byte, pSign []byte) (*types.Transaction, error) {
	return _IControl2.Contract.SubOrder(&_IControl2.TransactOpts, _a, _oi, uSign, pSign)
}

// SubOrder is a paid mutator transaction binding the contract method 0x42f45166.
//
// Solidity: function subOrder(address _a, (uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) _oi, bytes uSign, bytes pSign) returns()
func (_IControl2 *IControl2TransactorSession) SubOrder(_a common.Address, _oi OrderIn, uSign []byte, pSign []byte) (*types.Transaction, error) {
	return _IControl2.Contract.SubOrder(&_IControl2.TransactOpts, _a, _oi, uSign, pSign)
}

// Withdraw is a paid mutator transaction binding the contract method 0x9b4c757a.
//
// Solidity: function withdraw(address _a, uint64 _i, uint8 _ti, uint256 _money) returns()
func (_IControl2 *IControl2Transactor) Withdraw(opts *bind.TransactOpts, _a common.Address, _i uint64, _ti uint8, _money *big.Int) (*types.Transaction, error) {
	return _IControl2.contract.Transact(opts, "withdraw", _a, _i, _ti, _money)
}

// Withdraw is a paid mutator transaction binding the contract method 0x9b4c757a.
//
// Solidity: function withdraw(address _a, uint64 _i, uint8 _ti, uint256 _money) returns()
func (_IControl2 *IControl2Session) Withdraw(_a common.Address, _i uint64, _ti uint8, _money *big.Int) (*types.Transaction, error) {
	return _IControl2.Contract.Withdraw(&_IControl2.TransactOpts, _a, _i, _ti, _money)
}

// Withdraw is a paid mutator transaction binding the contract method 0x9b4c757a.
//
// Solidity: function withdraw(address _a, uint64 _i, uint8 _ti, uint256 _money) returns()
func (_IControl2 *IControl2TransactorSession) Withdraw(_a common.Address, _i uint64, _ti uint8, _money *big.Int) (*types.Transaction, error) {
	return _IControl2.Contract.Withdraw(&_IControl2.TransactOpts, _a, _i, _ti, _money)
}

// IControl2ProWithdrawIterator is returned from FilterProWithdraw and is used to iterate over the raw logs and unpacked data for ProWithdraw events raised by the IControl2 contract.
type IControl2ProWithdrawIterator struct {
	Event *IControl2ProWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IControl2ProWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IControl2ProWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IControl2ProWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IControl2ProWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IControl2ProWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IControl2ProWithdraw represents a ProWithdraw event raised by the IControl2 contract.
type IControl2ProWithdraw struct {
	A    common.Address
	Pi   uint64
	Ti   uint8
	Pay  *big.Int
	Lost *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterProWithdraw is a free log retrieval operation binding the contract event 0x3ea20fac35aae529e59d08cd5e2b0481108ccd275b50215084c05039245766db.
//
// Solidity: event ProWithdraw(address indexed a, uint64 indexed pi, uint8 ti, uint256 pay, uint256 lost)
func (_IControl2 *IControl2Filterer) FilterProWithdraw(opts *bind.FilterOpts, a []common.Address, pi []uint64) (*IControl2ProWithdrawIterator, error) {

	var aRule []interface{}
	for _, aItem := range a {
		aRule = append(aRule, aItem)
	}
	var piRule []interface{}
	for _, piItem := range pi {
		piRule = append(piRule, piItem)
	}

	logs, sub, err := _IControl2.contract.FilterLogs(opts, "ProWithdraw", aRule, piRule)
	if err != nil {
		return nil, err
	}
	return &IControl2ProWithdrawIterator{contract: _IControl2.contract, event: "ProWithdraw", logs: logs, sub: sub}, nil
}

// WatchProWithdraw is a free log subscription operation binding the contract event 0x3ea20fac35aae529e59d08cd5e2b0481108ccd275b50215084c05039245766db.
//
// Solidity: event ProWithdraw(address indexed a, uint64 indexed pi, uint8 ti, uint256 pay, uint256 lost)
func (_IControl2 *IControl2Filterer) WatchProWithdraw(opts *bind.WatchOpts, sink chan<- *IControl2ProWithdraw, a []common.Address, pi []uint64) (event.Subscription, error) {

	var aRule []interface{}
	for _, aItem := range a {
		aRule = append(aRule, aItem)
	}
	var piRule []interface{}
	for _, piItem := range pi {
		piRule = append(piRule, piItem)
	}

	logs, sub, err := _IControl2.contract.WatchLogs(opts, "ProWithdraw", aRule, piRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IControl2ProWithdraw)
				if err := _IControl2.contract.UnpackLog(event, "ProWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProWithdraw is a log parse operation binding the contract event 0x3ea20fac35aae529e59d08cd5e2b0481108ccd275b50215084c05039245766db.
//
// Solidity: event ProWithdraw(address indexed a, uint64 indexed pi, uint8 ti, uint256 pay, uint256 lost)
func (_IControl2 *IControl2Filterer) ParseProWithdraw(log types.Log) (*IControl2ProWithdraw, error) {
	event := new(IControl2ProWithdraw)
	if err := _IControl2.contract.UnpackLog(event, "ProWithdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IControl2RechargeIterator is returned from FilterRecharge and is used to iterate over the raw logs and unpacked data for Recharge events raised by the IControl2 contract.
type IControl2RechargeIterator struct {
	Event *IControl2Recharge // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IControl2RechargeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IControl2Recharge)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IControl2Recharge)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IControl2RechargeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IControl2RechargeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IControl2Recharge represents a Recharge event raised by the IControl2 contract.
type IControl2Recharge struct {
	Payer  common.Address
	I      uint64
	IsLock bool
	Ti     uint8
	Money  *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRecharge is a free log retrieval operation binding the contract event 0x544832b39fc44fc05cca7aa2c9f113bada9a6316b096b6cefcb302e433454a17.
//
// Solidity: event Recharge(address indexed payer, uint64 indexed i, bool indexed isLock, uint8 ti, uint256 money)
func (_IControl2 *IControl2Filterer) FilterRecharge(opts *bind.FilterOpts, payer []common.Address, i []uint64, isLock []bool) (*IControl2RechargeIterator, error) {

	var payerRule []interface{}
	for _, payerItem := range payer {
		payerRule = append(payerRule, payerItem)
	}
	var iRule []interface{}
	for _, iItem := range i {
		iRule = append(iRule, iItem)
	}
	var isLockRule []interface{}
	for _, isLockItem := range isLock {
		isLockRule = append(isLockRule, isLockItem)
	}

	logs, sub, err := _IControl2.contract.FilterLogs(opts, "Recharge", payerRule, iRule, isLockRule)
	if err != nil {
		return nil, err
	}
	return &IControl2RechargeIterator{contract: _IControl2.contract, event: "Recharge", logs: logs, sub: sub}, nil
}

// WatchRecharge is a free log subscription operation binding the contract event 0x544832b39fc44fc05cca7aa2c9f113bada9a6316b096b6cefcb302e433454a17.
//
// Solidity: event Recharge(address indexed payer, uint64 indexed i, bool indexed isLock, uint8 ti, uint256 money)
func (_IControl2 *IControl2Filterer) WatchRecharge(opts *bind.WatchOpts, sink chan<- *IControl2Recharge, payer []common.Address, i []uint64, isLock []bool) (event.Subscription, error) {

	var payerRule []interface{}
	for _, payerItem := range payer {
		payerRule = append(payerRule, payerItem)
	}
	var iRule []interface{}
	for _, iItem := range i {
		iRule = append(iRule, iItem)
	}
	var isLockRule []interface{}
	for _, isLockItem := range isLock {
		isLockRule = append(isLockRule, isLockItem)
	}

	logs, sub, err := _IControl2.contract.WatchLogs(opts, "Recharge", payerRule, iRule, isLockRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IControl2Recharge)
				if err := _IControl2.contract.UnpackLog(event, "Recharge", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRecharge is a log parse operation binding the contract event 0x544832b39fc44fc05cca7aa2c9f113bada9a6316b096b6cefcb302e433454a17.
//
// Solidity: event Recharge(address indexed payer, uint64 indexed i, bool indexed isLock, uint8 ti, uint256 money)
func (_IControl2 *IControl2Filterer) ParseRecharge(log types.Log) (*IControl2Recharge, error) {
	event := new(IControl2Recharge)
	if err := _IControl2.contract.UnpackLog(event, "Recharge", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IControl2WithdrawIterator is returned from FilterWithdraw and is used to iterate over the raw logs and unpacked data for Withdraw events raised by the IControl2 contract.
type IControl2WithdrawIterator struct {
	Event *IControl2Withdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IControl2WithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IControl2Withdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IControl2Withdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IControl2WithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IControl2WithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IControl2Withdraw represents a Withdraw event raised by the IControl2 contract.
type IControl2Withdraw struct {
	Addr        common.Address
	I           uint64
	Ti          uint8
	Money       *big.Int
	ActualMoney *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterWithdraw is a free log retrieval operation binding the contract event 0x8cf9f6665801a7a41feb765d72a4472b5f7d327ed18c77c6e81d2bb5622cd8c0.
//
// Solidity: event Withdraw(address indexed addr, uint64 indexed i, uint8 ti, uint256 money, uint256 actualMoney)
func (_IControl2 *IControl2Filterer) FilterWithdraw(opts *bind.FilterOpts, addr []common.Address, i []uint64) (*IControl2WithdrawIterator, error) {

	var addrRule []interface{}
	for _, addrItem := range addr {
		addrRule = append(addrRule, addrItem)
	}
	var iRule []interface{}
	for _, iItem := range i {
		iRule = append(iRule, iItem)
	}

	logs, sub, err := _IControl2.contract.FilterLogs(opts, "Withdraw", addrRule, iRule)
	if err != nil {
		return nil, err
	}
	return &IControl2WithdrawIterator{contract: _IControl2.contract, event: "Withdraw", logs: logs, sub: sub}, nil
}

// WatchWithdraw is a free log subscription operation binding the contract event 0x8cf9f6665801a7a41feb765d72a4472b5f7d327ed18c77c6e81d2bb5622cd8c0.
//
// Solidity: event Withdraw(address indexed addr, uint64 indexed i, uint8 ti, uint256 money, uint256 actualMoney)
func (_IControl2 *IControl2Filterer) WatchWithdraw(opts *bind.WatchOpts, sink chan<- *IControl2Withdraw, addr []common.Address, i []uint64) (event.Subscription, error) {

	var addrRule []interface{}
	for _, addrItem := range addr {
		addrRule = append(addrRule, addrItem)
	}
	var iRule []interface{}
	for _, iItem := range i {
		iRule = append(iRule, iItem)
	}

	logs, sub, err := _IControl2.contract.WatchLogs(opts, "Withdraw", addrRule, iRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IControl2Withdraw)
				if err := _IControl2.contract.UnpackLog(event, "Withdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdraw is a log parse operation binding the contract event 0x8cf9f6665801a7a41feb765d72a4472b5f7d327ed18c77c6e81d2bb5622cd8c0.
//
// Solidity: event Withdraw(address indexed addr, uint64 indexed i, uint8 ti, uint256 money, uint256 actualMoney)
func (_IControl2 *IControl2Filterer) ParseWithdraw(log types.Log) (*IControl2Withdraw, error) {
	event := new(IControl2Withdraw)
	if err := _IControl2.contract.UnpackLog(event, "Withdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20ABI is the input ABI used to generate the binding from.
const IERC20ABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IERC20FuncSigs maps the 4-byte function signature to its string representation.
var IERC20FuncSigs = map[string]string{
	"dd62ed3e": "allowance(address,address)",
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"42966c68": "burn(uint256)",
	"40c10f19": "mint(address,uint256)",
	"06fdde03": "name()",
	"95d89b41": "symbol()",
	"18160ddd": "totalSupply()",
	"a9059cbb": "transfer(address,uint256)",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// IERC20 is an auto generated Go binding around an Ethereum contract.
type IERC20 struct {
	IERC20Caller     // Read-only binding to the contract
	IERC20Transactor // Write-only binding to the contract
	IERC20Filterer   // Log filterer for contract events
}

// IERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type IERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC20Session struct {
	Contract     *IERC20           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC20CallerSession struct {
	Contract *IERC20Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC20TransactorSession struct {
	Contract     *IERC20Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type IERC20Raw struct {
	Contract *IERC20 // Generic contract binding to access the raw methods on
}

// IERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC20CallerRaw struct {
	Contract *IERC20Caller // Generic read-only contract binding to access the raw methods on
}

// IERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC20TransactorRaw struct {
	Contract *IERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20 creates a new instance of IERC20, bound to a specific deployed contract.
func NewIERC20(address common.Address, backend bind.ContractBackend) (*IERC20, error) {
	contract, err := bindIERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20{IERC20Caller: IERC20Caller{contract: contract}, IERC20Transactor: IERC20Transactor{contract: contract}, IERC20Filterer: IERC20Filterer{contract: contract}}, nil
}

// NewIERC20Caller creates a new read-only instance of IERC20, bound to a specific deployed contract.
func NewIERC20Caller(address common.Address, caller bind.ContractCaller) (*IERC20Caller, error) {
	contract, err := bindIERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20Caller{contract: contract}, nil
}

// NewIERC20Transactor creates a new write-only instance of IERC20, bound to a specific deployed contract.
func NewIERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*IERC20Transactor, error) {
	contract, err := bindIERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20Transactor{contract: contract}, nil
}

// NewIERC20Filterer creates a new log filterer instance of IERC20, bound to a specific deployed contract.
func NewIERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*IERC20Filterer, error) {
	contract, err := bindIERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20Filterer{contract: contract}, nil
}

// bindIERC20 binds a generic wrapper to an already deployed contract.
func bindIERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC20ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20 *IERC20Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20.Contract.IERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20 *IERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20.Contract.IERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20 *IERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20.Contract.IERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20 *IERC20CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20 *IERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20 *IERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20Caller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20Session) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20.Contract.Allowance(&_IERC20.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20CallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20.Contract.Allowance(&_IERC20.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20Caller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20Session) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20.Contract.BalanceOf(&_IERC20.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20CallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20.Contract.BalanceOf(&_IERC20.CallOpts, account)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20 *IERC20Caller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20 *IERC20Session) Name() (string, error) {
	return _IERC20.Contract.Name(&_IERC20.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20 *IERC20CallerSession) Name() (string, error) {
	return _IERC20.Contract.Name(&_IERC20.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20 *IERC20Caller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20 *IERC20Session) Symbol() (string, error) {
	return _IERC20.Contract.Symbol(&_IERC20.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20 *IERC20CallerSession) Symbol() (string, error) {
	return _IERC20.Contract.Symbol(&_IERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20Session) TotalSupply() (*big.Int, error) {
	return _IERC20.Contract.TotalSupply(&_IERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _IERC20.Contract.TotalSupply(&_IERC20.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns()
func (_IERC20 *IERC20Transactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns()
func (_IERC20 *IERC20Session) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Approve(&_IERC20.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns()
func (_IERC20 *IERC20TransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Approve(&_IERC20.TransactOpts, spender, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_IERC20 *IERC20Transactor) Burn(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "burn", amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_IERC20 *IERC20Session) Burn(amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Burn(&_IERC20.TransactOpts, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_IERC20 *IERC20TransactorSession) Burn(amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Burn(&_IERC20.TransactOpts, amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address target, uint256 amount) returns()
func (_IERC20 *IERC20Transactor) Mint(opts *bind.TransactOpts, target common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "mint", target, amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address target, uint256 amount) returns()
func (_IERC20 *IERC20Session) Mint(target common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Mint(&_IERC20.TransactOpts, target, amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address target, uint256 amount) returns()
func (_IERC20 *IERC20TransactorSession) Mint(target common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Mint(&_IERC20.TransactOpts, target, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address recipient, uint256 amount) returns()
func (_IERC20 *IERC20Transactor) Transfer(opts *bind.TransactOpts, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "transfer", recipient, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address recipient, uint256 amount) returns()
func (_IERC20 *IERC20Session) Transfer(recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Transfer(&_IERC20.TransactOpts, recipient, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address recipient, uint256 amount) returns()
func (_IERC20 *IERC20TransactorSession) Transfer(recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Transfer(&_IERC20.TransactOpts, recipient, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address sender, address recipient, uint256 amount) returns()
func (_IERC20 *IERC20Transactor) TransferFrom(opts *bind.TransactOpts, sender common.Address, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "transferFrom", sender, recipient, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address sender, address recipient, uint256 amount) returns()
func (_IERC20 *IERC20Session) TransferFrom(sender common.Address, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.TransferFrom(&_IERC20.TransactOpts, sender, recipient, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address sender, address recipient, uint256 amount) returns()
func (_IERC20 *IERC20TransactorSession) TransferFrom(sender common.Address, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.TransferFrom(&_IERC20.TransactOpts, sender, recipient, amount)
}

// IERC20ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC20 contract.
type IERC20ApprovalIterator struct {
	Event *IERC20Approval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20ApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20ApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20Approval represents a Approval event raised by the IERC20 contract.
type IERC20Approval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*IERC20ApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &IERC20ApprovalIterator{contract: _IERC20.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC20Approval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20Approval)
				if err := _IERC20.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) ParseApproval(log types.Log) (*IERC20Approval, error) {
	event := new(IERC20Approval)
	if err := _IERC20.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC20 contract.
type IERC20TransferIterator struct {
	Event *IERC20Transfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20TransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20TransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20Transfer represents a Transfer event raised by the IERC20 contract.
type IERC20Transfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*IERC20TransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC20TransferIterator{contract: _IERC20.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC20Transfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20Transfer)
				if err := _IERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) ParseTransfer(log types.Log) (*IERC20Transfer, error) {
	event := new(IERC20Transfer)
	if err := _IERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IFileSysSetterABI is the input ABI used to generate the binding from.
const IFileSysSetterABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"ti\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"ui\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"pi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"size\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sprice\",\"type\":\"uint256\"}],\"name\":\"AddOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"ti\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"ui\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"pi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"size\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sprice\",\"type\":\"uint256\"}],\"name\":\"AddRepair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"ti\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"ui\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"pi\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"size\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sprice\",\"type\":\"uint256\"}],\"name\":\"SubOrder\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"uIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"pIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"size\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"tIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"sprice\",\"type\":\"uint256\"}],\"internalType\":\"structOrderIn\",\"name\":\"ps\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_mr\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_gi\",\"type\":\"uint64\"}],\"name\":\"addOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"uIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"pIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"size\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"tIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"sprice\",\"type\":\"uint256\"}],\"internalType\":\"structOrderIn\",\"name\":\"ps\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"_gi\",\"type\":\"uint64\"}],\"name\":\"addRepair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"pIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"tIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"pay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lost\",\"type\":\"uint256\"}],\"internalType\":\"structPWIn\",\"name\":\"ps\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"_gi\",\"type\":\"uint64\"}],\"name\":\"proWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_i\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isLock\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"recharge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"uIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"pIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"size\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"tIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"sprice\",\"type\":\"uint256\"}],\"internalType\":\"structOrderIn\",\"name\":\"ps\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"_gi\",\"type\":\"uint64\"}],\"name\":\"subOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_i\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IFileSysSetterFuncSigs maps the 4-byte function signature to its string representation.
var IFileSysSetterFuncSigs = map[string]string{
	"89cdc743": "addOrder((uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256),uint256,uint64)",
	"80faaf88": "addRepair((uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256),uint64)",
	"a4703e16": "proWithdraw((uint64,uint8,uint256,uint256),uint64)",
	"24d11d40": "recharge(uint64,uint8,bool,uint256)",
	"248d02a0": "subOrder((uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256),uint64)",
	"259c6d5e": "withdraw(uint64,uint8,uint256)",
}

// IFileSysSetter is an auto generated Go binding around an Ethereum contract.
type IFileSysSetter struct {
	IFileSysSetterCaller     // Read-only binding to the contract
	IFileSysSetterTransactor // Write-only binding to the contract
	IFileSysSetterFilterer   // Log filterer for contract events
}

// IFileSysSetterCaller is an auto generated read-only Go binding around an Ethereum contract.
type IFileSysSetterCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFileSysSetterTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IFileSysSetterTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFileSysSetterFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IFileSysSetterFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFileSysSetterSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IFileSysSetterSession struct {
	Contract     *IFileSysSetter   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IFileSysSetterCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IFileSysSetterCallerSession struct {
	Contract *IFileSysSetterCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IFileSysSetterTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IFileSysSetterTransactorSession struct {
	Contract     *IFileSysSetterTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IFileSysSetterRaw is an auto generated low-level Go binding around an Ethereum contract.
type IFileSysSetterRaw struct {
	Contract *IFileSysSetter // Generic contract binding to access the raw methods on
}

// IFileSysSetterCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IFileSysSetterCallerRaw struct {
	Contract *IFileSysSetterCaller // Generic read-only contract binding to access the raw methods on
}

// IFileSysSetterTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IFileSysSetterTransactorRaw struct {
	Contract *IFileSysSetterTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIFileSysSetter creates a new instance of IFileSysSetter, bound to a specific deployed contract.
func NewIFileSysSetter(address common.Address, backend bind.ContractBackend) (*IFileSysSetter, error) {
	contract, err := bindIFileSysSetter(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IFileSysSetter{IFileSysSetterCaller: IFileSysSetterCaller{contract: contract}, IFileSysSetterTransactor: IFileSysSetterTransactor{contract: contract}, IFileSysSetterFilterer: IFileSysSetterFilterer{contract: contract}}, nil
}

// NewIFileSysSetterCaller creates a new read-only instance of IFileSysSetter, bound to a specific deployed contract.
func NewIFileSysSetterCaller(address common.Address, caller bind.ContractCaller) (*IFileSysSetterCaller, error) {
	contract, err := bindIFileSysSetter(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IFileSysSetterCaller{contract: contract}, nil
}

// NewIFileSysSetterTransactor creates a new write-only instance of IFileSysSetter, bound to a specific deployed contract.
func NewIFileSysSetterTransactor(address common.Address, transactor bind.ContractTransactor) (*IFileSysSetterTransactor, error) {
	contract, err := bindIFileSysSetter(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IFileSysSetterTransactor{contract: contract}, nil
}

// NewIFileSysSetterFilterer creates a new log filterer instance of IFileSysSetter, bound to a specific deployed contract.
func NewIFileSysSetterFilterer(address common.Address, filterer bind.ContractFilterer) (*IFileSysSetterFilterer, error) {
	contract, err := bindIFileSysSetter(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IFileSysSetterFilterer{contract: contract}, nil
}

// bindIFileSysSetter binds a generic wrapper to an already deployed contract.
func bindIFileSysSetter(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IFileSysSetterABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IFileSysSetter *IFileSysSetterRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IFileSysSetter.Contract.IFileSysSetterCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IFileSysSetter *IFileSysSetterRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.IFileSysSetterTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IFileSysSetter *IFileSysSetterRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.IFileSysSetterTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IFileSysSetter *IFileSysSetterCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IFileSysSetter.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IFileSysSetter *IFileSysSetterTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IFileSysSetter *IFileSysSetterTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.contract.Transact(opts, method, params...)
}

// AddOrder is a paid mutator transaction binding the contract method 0x89cdc743.
//
// Solidity: function addOrder((uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, uint256 _mr, uint64 _gi) returns()
func (_IFileSysSetter *IFileSysSetterTransactor) AddOrder(opts *bind.TransactOpts, ps OrderIn, _mr *big.Int, _gi uint64) (*types.Transaction, error) {
	return _IFileSysSetter.contract.Transact(opts, "addOrder", ps, _mr, _gi)
}

// AddOrder is a paid mutator transaction binding the contract method 0x89cdc743.
//
// Solidity: function addOrder((uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, uint256 _mr, uint64 _gi) returns()
func (_IFileSysSetter *IFileSysSetterSession) AddOrder(ps OrderIn, _mr *big.Int, _gi uint64) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.AddOrder(&_IFileSysSetter.TransactOpts, ps, _mr, _gi)
}

// AddOrder is a paid mutator transaction binding the contract method 0x89cdc743.
//
// Solidity: function addOrder((uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, uint256 _mr, uint64 _gi) returns()
func (_IFileSysSetter *IFileSysSetterTransactorSession) AddOrder(ps OrderIn, _mr *big.Int, _gi uint64) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.AddOrder(&_IFileSysSetter.TransactOpts, ps, _mr, _gi)
}

// AddRepair is a paid mutator transaction binding the contract method 0x80faaf88.
//
// Solidity: function addRepair((uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, uint64 _gi) returns()
func (_IFileSysSetter *IFileSysSetterTransactor) AddRepair(opts *bind.TransactOpts, ps OrderIn, _gi uint64) (*types.Transaction, error) {
	return _IFileSysSetter.contract.Transact(opts, "addRepair", ps, _gi)
}

// AddRepair is a paid mutator transaction binding the contract method 0x80faaf88.
//
// Solidity: function addRepair((uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, uint64 _gi) returns()
func (_IFileSysSetter *IFileSysSetterSession) AddRepair(ps OrderIn, _gi uint64) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.AddRepair(&_IFileSysSetter.TransactOpts, ps, _gi)
}

// AddRepair is a paid mutator transaction binding the contract method 0x80faaf88.
//
// Solidity: function addRepair((uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, uint64 _gi) returns()
func (_IFileSysSetter *IFileSysSetterTransactorSession) AddRepair(ps OrderIn, _gi uint64) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.AddRepair(&_IFileSysSetter.TransactOpts, ps, _gi)
}

// ProWithdraw is a paid mutator transaction binding the contract method 0xa4703e16.
//
// Solidity: function proWithdraw((uint64,uint8,uint256,uint256) ps, uint64 _gi) returns(uint256)
func (_IFileSysSetter *IFileSysSetterTransactor) ProWithdraw(opts *bind.TransactOpts, ps PWIn, _gi uint64) (*types.Transaction, error) {
	return _IFileSysSetter.contract.Transact(opts, "proWithdraw", ps, _gi)
}

// ProWithdraw is a paid mutator transaction binding the contract method 0xa4703e16.
//
// Solidity: function proWithdraw((uint64,uint8,uint256,uint256) ps, uint64 _gi) returns(uint256)
func (_IFileSysSetter *IFileSysSetterSession) ProWithdraw(ps PWIn, _gi uint64) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.ProWithdraw(&_IFileSysSetter.TransactOpts, ps, _gi)
}

// ProWithdraw is a paid mutator transaction binding the contract method 0xa4703e16.
//
// Solidity: function proWithdraw((uint64,uint8,uint256,uint256) ps, uint64 _gi) returns(uint256)
func (_IFileSysSetter *IFileSysSetterTransactorSession) ProWithdraw(ps PWIn, _gi uint64) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.ProWithdraw(&_IFileSysSetter.TransactOpts, ps, _gi)
}

// Recharge is a paid mutator transaction binding the contract method 0x24d11d40.
//
// Solidity: function recharge(uint64 _i, uint8 _ti, bool isLock, uint256 money) returns()
func (_IFileSysSetter *IFileSysSetterTransactor) Recharge(opts *bind.TransactOpts, _i uint64, _ti uint8, isLock bool, money *big.Int) (*types.Transaction, error) {
	return _IFileSysSetter.contract.Transact(opts, "recharge", _i, _ti, isLock, money)
}

// Recharge is a paid mutator transaction binding the contract method 0x24d11d40.
//
// Solidity: function recharge(uint64 _i, uint8 _ti, bool isLock, uint256 money) returns()
func (_IFileSysSetter *IFileSysSetterSession) Recharge(_i uint64, _ti uint8, isLock bool, money *big.Int) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.Recharge(&_IFileSysSetter.TransactOpts, _i, _ti, isLock, money)
}

// Recharge is a paid mutator transaction binding the contract method 0x24d11d40.
//
// Solidity: function recharge(uint64 _i, uint8 _ti, bool isLock, uint256 money) returns()
func (_IFileSysSetter *IFileSysSetterTransactorSession) Recharge(_i uint64, _ti uint8, isLock bool, money *big.Int) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.Recharge(&_IFileSysSetter.TransactOpts, _i, _ti, isLock, money)
}

// SubOrder is a paid mutator transaction binding the contract method 0x248d02a0.
//
// Solidity: function subOrder((uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, uint64 _gi) returns()
func (_IFileSysSetter *IFileSysSetterTransactor) SubOrder(opts *bind.TransactOpts, ps OrderIn, _gi uint64) (*types.Transaction, error) {
	return _IFileSysSetter.contract.Transact(opts, "subOrder", ps, _gi)
}

// SubOrder is a paid mutator transaction binding the contract method 0x248d02a0.
//
// Solidity: function subOrder((uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, uint64 _gi) returns()
func (_IFileSysSetter *IFileSysSetterSession) SubOrder(ps OrderIn, _gi uint64) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.SubOrder(&_IFileSysSetter.TransactOpts, ps, _gi)
}

// SubOrder is a paid mutator transaction binding the contract method 0x248d02a0.
//
// Solidity: function subOrder((uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint256) ps, uint64 _gi) returns()
func (_IFileSysSetter *IFileSysSetterTransactorSession) SubOrder(ps OrderIn, _gi uint64) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.SubOrder(&_IFileSysSetter.TransactOpts, ps, _gi)
}

// Withdraw is a paid mutator transaction binding the contract method 0x259c6d5e.
//
// Solidity: function withdraw(uint64 _i, uint8 _ti, uint256 money) returns(uint256)
func (_IFileSysSetter *IFileSysSetterTransactor) Withdraw(opts *bind.TransactOpts, _i uint64, _ti uint8, money *big.Int) (*types.Transaction, error) {
	return _IFileSysSetter.contract.Transact(opts, "withdraw", _i, _ti, money)
}

// Withdraw is a paid mutator transaction binding the contract method 0x259c6d5e.
//
// Solidity: function withdraw(uint64 _i, uint8 _ti, uint256 money) returns(uint256)
func (_IFileSysSetter *IFileSysSetterSession) Withdraw(_i uint64, _ti uint8, money *big.Int) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.Withdraw(&_IFileSysSetter.TransactOpts, _i, _ti, money)
}

// Withdraw is a paid mutator transaction binding the contract method 0x259c6d5e.
//
// Solidity: function withdraw(uint64 _i, uint8 _ti, uint256 money) returns(uint256)
func (_IFileSysSetter *IFileSysSetterTransactorSession) Withdraw(_i uint64, _ti uint8, money *big.Int) (*types.Transaction, error) {
	return _IFileSysSetter.Contract.Withdraw(&_IFileSysSetter.TransactOpts, _i, _ti, money)
}

// IFileSysSetterAddOrderIterator is returned from FilterAddOrder and is used to iterate over the raw logs and unpacked data for AddOrder events raised by the IFileSysSetter contract.
type IFileSysSetterAddOrderIterator struct {
	Event *IFileSysSetterAddOrder // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IFileSysSetterAddOrderIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IFileSysSetterAddOrder)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IFileSysSetterAddOrder)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IFileSysSetterAddOrderIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IFileSysSetterAddOrderIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IFileSysSetterAddOrder represents a AddOrder event raised by the IFileSysSetter contract.
type IFileSysSetterAddOrder struct {
	Ti     uint8
	Ui     uint64
	Pi     uint64
	Start  uint64
	End    uint64
	Size   uint64
	Sprice *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterAddOrder is a free log retrieval operation binding the contract event 0x9ad187def591246eb8fff84534926005f62988636593745516c0ac08fa086314.
//
// Solidity: event AddOrder(uint8 indexed ti, uint64 indexed ui, uint64 indexed pi, uint64 start, uint64 end, uint64 size, uint256 sprice)
func (_IFileSysSetter *IFileSysSetterFilterer) FilterAddOrder(opts *bind.FilterOpts, ti []uint8, ui []uint64, pi []uint64) (*IFileSysSetterAddOrderIterator, error) {

	var tiRule []interface{}
	for _, tiItem := range ti {
		tiRule = append(tiRule, tiItem)
	}
	var uiRule []interface{}
	for _, uiItem := range ui {
		uiRule = append(uiRule, uiItem)
	}
	var piRule []interface{}
	for _, piItem := range pi {
		piRule = append(piRule, piItem)
	}

	logs, sub, err := _IFileSysSetter.contract.FilterLogs(opts, "AddOrder", tiRule, uiRule, piRule)
	if err != nil {
		return nil, err
	}
	return &IFileSysSetterAddOrderIterator{contract: _IFileSysSetter.contract, event: "AddOrder", logs: logs, sub: sub}, nil
}

// WatchAddOrder is a free log subscription operation binding the contract event 0x9ad187def591246eb8fff84534926005f62988636593745516c0ac08fa086314.
//
// Solidity: event AddOrder(uint8 indexed ti, uint64 indexed ui, uint64 indexed pi, uint64 start, uint64 end, uint64 size, uint256 sprice)
func (_IFileSysSetter *IFileSysSetterFilterer) WatchAddOrder(opts *bind.WatchOpts, sink chan<- *IFileSysSetterAddOrder, ti []uint8, ui []uint64, pi []uint64) (event.Subscription, error) {

	var tiRule []interface{}
	for _, tiItem := range ti {
		tiRule = append(tiRule, tiItem)
	}
	var uiRule []interface{}
	for _, uiItem := range ui {
		uiRule = append(uiRule, uiItem)
	}
	var piRule []interface{}
	for _, piItem := range pi {
		piRule = append(piRule, piItem)
	}

	logs, sub, err := _IFileSysSetter.contract.WatchLogs(opts, "AddOrder", tiRule, uiRule, piRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IFileSysSetterAddOrder)
				if err := _IFileSysSetter.contract.UnpackLog(event, "AddOrder", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddOrder is a log parse operation binding the contract event 0x9ad187def591246eb8fff84534926005f62988636593745516c0ac08fa086314.
//
// Solidity: event AddOrder(uint8 indexed ti, uint64 indexed ui, uint64 indexed pi, uint64 start, uint64 end, uint64 size, uint256 sprice)
func (_IFileSysSetter *IFileSysSetterFilterer) ParseAddOrder(log types.Log) (*IFileSysSetterAddOrder, error) {
	event := new(IFileSysSetterAddOrder)
	if err := _IFileSysSetter.contract.UnpackLog(event, "AddOrder", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IFileSysSetterAddRepairIterator is returned from FilterAddRepair and is used to iterate over the raw logs and unpacked data for AddRepair events raised by the IFileSysSetter contract.
type IFileSysSetterAddRepairIterator struct {
	Event *IFileSysSetterAddRepair // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IFileSysSetterAddRepairIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IFileSysSetterAddRepair)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IFileSysSetterAddRepair)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IFileSysSetterAddRepairIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IFileSysSetterAddRepairIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IFileSysSetterAddRepair represents a AddRepair event raised by the IFileSysSetter contract.
type IFileSysSetterAddRepair struct {
	Ti     uint8
	Ui     uint64
	Pi     uint64
	Start  uint64
	End    uint64
	Size   uint64
	Sprice *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterAddRepair is a free log retrieval operation binding the contract event 0x82f944cf0134663ff19eea526226f1cd8d5746a71cc837983659b8cbb2674e48.
//
// Solidity: event AddRepair(uint8 indexed ti, uint64 indexed ui, uint64 indexed pi, uint64 start, uint64 end, uint64 size, uint256 sprice)
func (_IFileSysSetter *IFileSysSetterFilterer) FilterAddRepair(opts *bind.FilterOpts, ti []uint8, ui []uint64, pi []uint64) (*IFileSysSetterAddRepairIterator, error) {

	var tiRule []interface{}
	for _, tiItem := range ti {
		tiRule = append(tiRule, tiItem)
	}
	var uiRule []interface{}
	for _, uiItem := range ui {
		uiRule = append(uiRule, uiItem)
	}
	var piRule []interface{}
	for _, piItem := range pi {
		piRule = append(piRule, piItem)
	}

	logs, sub, err := _IFileSysSetter.contract.FilterLogs(opts, "AddRepair", tiRule, uiRule, piRule)
	if err != nil {
		return nil, err
	}
	return &IFileSysSetterAddRepairIterator{contract: _IFileSysSetter.contract, event: "AddRepair", logs: logs, sub: sub}, nil
}

// WatchAddRepair is a free log subscription operation binding the contract event 0x82f944cf0134663ff19eea526226f1cd8d5746a71cc837983659b8cbb2674e48.
//
// Solidity: event AddRepair(uint8 indexed ti, uint64 indexed ui, uint64 indexed pi, uint64 start, uint64 end, uint64 size, uint256 sprice)
func (_IFileSysSetter *IFileSysSetterFilterer) WatchAddRepair(opts *bind.WatchOpts, sink chan<- *IFileSysSetterAddRepair, ti []uint8, ui []uint64, pi []uint64) (event.Subscription, error) {

	var tiRule []interface{}
	for _, tiItem := range ti {
		tiRule = append(tiRule, tiItem)
	}
	var uiRule []interface{}
	for _, uiItem := range ui {
		uiRule = append(uiRule, uiItem)
	}
	var piRule []interface{}
	for _, piItem := range pi {
		piRule = append(piRule, piItem)
	}

	logs, sub, err := _IFileSysSetter.contract.WatchLogs(opts, "AddRepair", tiRule, uiRule, piRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IFileSysSetterAddRepair)
				if err := _IFileSysSetter.contract.UnpackLog(event, "AddRepair", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddRepair is a log parse operation binding the contract event 0x82f944cf0134663ff19eea526226f1cd8d5746a71cc837983659b8cbb2674e48.
//
// Solidity: event AddRepair(uint8 indexed ti, uint64 indexed ui, uint64 indexed pi, uint64 start, uint64 end, uint64 size, uint256 sprice)
func (_IFileSysSetter *IFileSysSetterFilterer) ParseAddRepair(log types.Log) (*IFileSysSetterAddRepair, error) {
	event := new(IFileSysSetterAddRepair)
	if err := _IFileSysSetter.contract.UnpackLog(event, "AddRepair", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IFileSysSetterSubOrderIterator is returned from FilterSubOrder and is used to iterate over the raw logs and unpacked data for SubOrder events raised by the IFileSysSetter contract.
type IFileSysSetterSubOrderIterator struct {
	Event *IFileSysSetterSubOrder // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IFileSysSetterSubOrderIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IFileSysSetterSubOrder)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IFileSysSetterSubOrder)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IFileSysSetterSubOrderIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IFileSysSetterSubOrderIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IFileSysSetterSubOrder represents a SubOrder event raised by the IFileSysSetter contract.
type IFileSysSetterSubOrder struct {
	Ti     uint8
	Ui     uint64
	Pi     uint64
	Start  uint64
	End    uint64
	Size   uint64
	Sprice *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterSubOrder is a free log retrieval operation binding the contract event 0xe42ef64dc7dfe9121f13026a70df328cf6687348fdf8f71745f8e40fa5e52b82.
//
// Solidity: event SubOrder(uint8 indexed ti, uint64 indexed ui, uint64 indexed pi, uint64 start, uint64 end, uint64 size, uint256 sprice)
func (_IFileSysSetter *IFileSysSetterFilterer) FilterSubOrder(opts *bind.FilterOpts, ti []uint8, ui []uint64, pi []uint64) (*IFileSysSetterSubOrderIterator, error) {

	var tiRule []interface{}
	for _, tiItem := range ti {
		tiRule = append(tiRule, tiItem)
	}
	var uiRule []interface{}
	for _, uiItem := range ui {
		uiRule = append(uiRule, uiItem)
	}
	var piRule []interface{}
	for _, piItem := range pi {
		piRule = append(piRule, piItem)
	}

	logs, sub, err := _IFileSysSetter.contract.FilterLogs(opts, "SubOrder", tiRule, uiRule, piRule)
	if err != nil {
		return nil, err
	}
	return &IFileSysSetterSubOrderIterator{contract: _IFileSysSetter.contract, event: "SubOrder", logs: logs, sub: sub}, nil
}

// WatchSubOrder is a free log subscription operation binding the contract event 0xe42ef64dc7dfe9121f13026a70df328cf6687348fdf8f71745f8e40fa5e52b82.
//
// Solidity: event SubOrder(uint8 indexed ti, uint64 indexed ui, uint64 indexed pi, uint64 start, uint64 end, uint64 size, uint256 sprice)
func (_IFileSysSetter *IFileSysSetterFilterer) WatchSubOrder(opts *bind.WatchOpts, sink chan<- *IFileSysSetterSubOrder, ti []uint8, ui []uint64, pi []uint64) (event.Subscription, error) {

	var tiRule []interface{}
	for _, tiItem := range ti {
		tiRule = append(tiRule, tiItem)
	}
	var uiRule []interface{}
	for _, uiItem := range ui {
		uiRule = append(uiRule, uiItem)
	}
	var piRule []interface{}
	for _, piItem := range pi {
		piRule = append(piRule, piItem)
	}

	logs, sub, err := _IFileSysSetter.contract.WatchLogs(opts, "SubOrder", tiRule, uiRule, piRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IFileSysSetterSubOrder)
				if err := _IFileSysSetter.contract.UnpackLog(event, "SubOrder", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSubOrder is a log parse operation binding the contract event 0xe42ef64dc7dfe9121f13026a70df328cf6687348fdf8f71745f8e40fa5e52b82.
//
// Solidity: event SubOrder(uint8 indexed ti, uint64 indexed ui, uint64 indexed pi, uint64 start, uint64 end, uint64 size, uint256 sprice)
func (_IFileSysSetter *IFileSysSetterFilterer) ParseSubOrder(log types.Log) (*IFileSysSetterSubOrder, error) {
	event := new(IFileSysSetterSubOrder)
	if err := _IFileSysSetter.contract.UnpackLog(event, "SubOrder", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IGroupGetterABI is the input ABI used to generate the binding from.
const IGroupGetterABI = "[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_rType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"_gi\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_pm\",\"type\":\"uint256\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"i\",\"type\":\"uint64\"}],\"name\":\"checkG\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGCnt\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"i\",\"type\":\"uint64\"}],\"name\":\"getGInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_i\",\"type\":\"uint64\"}],\"name\":\"getKManage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"i\",\"type\":\"uint64\"}],\"name\":\"getLevel\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_i\",\"type\":\"uint64\"}],\"name\":\"getPInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"i\",\"type\":\"uint64\"}],\"name\":\"getSStra\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// IGroupGetterFuncSigs maps the 4-byte function signature to its string representation.
var IGroupGetterFuncSigs = map[string]string{
	"4acc2468": "add(uint8,uint64,uint256)",
	"83889fe3": "checkG(uint64)",
	"059e783d": "getGCnt()",
	"38add6a1": "getGInfo(uint64)",
	"929629d2": "getKManage(uint64)",
	"770609a8": "getLevel(uint64)",
	"50aa2329": "getPInfo(uint64)",
	"dc698953": "getSStra(uint64)",
}

// IGroupGetter is an auto generated Go binding around an Ethereum contract.
type IGroupGetter struct {
	IGroupGetterCaller     // Read-only binding to the contract
	IGroupGetterTransactor // Write-only binding to the contract
	IGroupGetterFilterer   // Log filterer for contract events
}

// IGroupGetterCaller is an auto generated read-only Go binding around an Ethereum contract.
type IGroupGetterCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IGroupGetterTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IGroupGetterTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IGroupGetterFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IGroupGetterFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IGroupGetterSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IGroupGetterSession struct {
	Contract     *IGroupGetter     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IGroupGetterCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IGroupGetterCallerSession struct {
	Contract *IGroupGetterCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IGroupGetterTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IGroupGetterTransactorSession struct {
	Contract     *IGroupGetterTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IGroupGetterRaw is an auto generated low-level Go binding around an Ethereum contract.
type IGroupGetterRaw struct {
	Contract *IGroupGetter // Generic contract binding to access the raw methods on
}

// IGroupGetterCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IGroupGetterCallerRaw struct {
	Contract *IGroupGetterCaller // Generic read-only contract binding to access the raw methods on
}

// IGroupGetterTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IGroupGetterTransactorRaw struct {
	Contract *IGroupGetterTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIGroupGetter creates a new instance of IGroupGetter, bound to a specific deployed contract.
func NewIGroupGetter(address common.Address, backend bind.ContractBackend) (*IGroupGetter, error) {
	contract, err := bindIGroupGetter(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IGroupGetter{IGroupGetterCaller: IGroupGetterCaller{contract: contract}, IGroupGetterTransactor: IGroupGetterTransactor{contract: contract}, IGroupGetterFilterer: IGroupGetterFilterer{contract: contract}}, nil
}

// NewIGroupGetterCaller creates a new read-only instance of IGroupGetter, bound to a specific deployed contract.
func NewIGroupGetterCaller(address common.Address, caller bind.ContractCaller) (*IGroupGetterCaller, error) {
	contract, err := bindIGroupGetter(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IGroupGetterCaller{contract: contract}, nil
}

// NewIGroupGetterTransactor creates a new write-only instance of IGroupGetter, bound to a specific deployed contract.
func NewIGroupGetterTransactor(address common.Address, transactor bind.ContractTransactor) (*IGroupGetterTransactor, error) {
	contract, err := bindIGroupGetter(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IGroupGetterTransactor{contract: contract}, nil
}

// NewIGroupGetterFilterer creates a new log filterer instance of IGroupGetter, bound to a specific deployed contract.
func NewIGroupGetterFilterer(address common.Address, filterer bind.ContractFilterer) (*IGroupGetterFilterer, error) {
	contract, err := bindIGroupGetter(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IGroupGetterFilterer{contract: contract}, nil
}

// bindIGroupGetter binds a generic wrapper to an already deployed contract.
func bindIGroupGetter(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IGroupGetterABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IGroupGetter *IGroupGetterRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IGroupGetter.Contract.IGroupGetterCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IGroupGetter *IGroupGetterRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IGroupGetter.Contract.IGroupGetterTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IGroupGetter *IGroupGetterRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IGroupGetter.Contract.IGroupGetterTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IGroupGetter *IGroupGetterCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IGroupGetter.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IGroupGetter *IGroupGetterTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IGroupGetter.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IGroupGetter *IGroupGetterTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IGroupGetter.Contract.contract.Transact(opts, method, params...)
}

// Add is a free data retrieval call binding the contract method 0x4acc2468.
//
// Solidity: function add(uint8 _rType, uint64 _gi, uint256 _pm) view returns()
func (_IGroupGetter *IGroupGetterCaller) Add(opts *bind.CallOpts, _rType uint8, _gi uint64, _pm *big.Int) error {
	var out []interface{}
	err := _IGroupGetter.contract.Call(opts, &out, "add", _rType, _gi, _pm)

	if err != nil {
		return err
	}

	return err

}

// Add is a free data retrieval call binding the contract method 0x4acc2468.
//
// Solidity: function add(uint8 _rType, uint64 _gi, uint256 _pm) view returns()
func (_IGroupGetter *IGroupGetterSession) Add(_rType uint8, _gi uint64, _pm *big.Int) error {
	return _IGroupGetter.Contract.Add(&_IGroupGetter.CallOpts, _rType, _gi, _pm)
}

// Add is a free data retrieval call binding the contract method 0x4acc2468.
//
// Solidity: function add(uint8 _rType, uint64 _gi, uint256 _pm) view returns()
func (_IGroupGetter *IGroupGetterCallerSession) Add(_rType uint8, _gi uint64, _pm *big.Int) error {
	return _IGroupGetter.Contract.Add(&_IGroupGetter.CallOpts, _rType, _gi, _pm)
}

// CheckG is a free data retrieval call binding the contract method 0x83889fe3.
//
// Solidity: function checkG(uint64 i) view returns()
func (_IGroupGetter *IGroupGetterCaller) CheckG(opts *bind.CallOpts, i uint64) error {
	var out []interface{}
	err := _IGroupGetter.contract.Call(opts, &out, "checkG", i)

	if err != nil {
		return err
	}

	return err

}

// CheckG is a free data retrieval call binding the contract method 0x83889fe3.
//
// Solidity: function checkG(uint64 i) view returns()
func (_IGroupGetter *IGroupGetterSession) CheckG(i uint64) error {
	return _IGroupGetter.Contract.CheckG(&_IGroupGetter.CallOpts, i)
}

// CheckG is a free data retrieval call binding the contract method 0x83889fe3.
//
// Solidity: function checkG(uint64 i) view returns()
func (_IGroupGetter *IGroupGetterCallerSession) CheckG(i uint64) error {
	return _IGroupGetter.Contract.CheckG(&_IGroupGetter.CallOpts, i)
}

// GetGCnt is a free data retrieval call binding the contract method 0x059e783d.
//
// Solidity: function getGCnt() view returns(uint64)
func (_IGroupGetter *IGroupGetterCaller) GetGCnt(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _IGroupGetter.contract.Call(opts, &out, "getGCnt")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// GetGCnt is a free data retrieval call binding the contract method 0x059e783d.
//
// Solidity: function getGCnt() view returns(uint64)
func (_IGroupGetter *IGroupGetterSession) GetGCnt() (uint64, error) {
	return _IGroupGetter.Contract.GetGCnt(&_IGroupGetter.CallOpts)
}

// GetGCnt is a free data retrieval call binding the contract method 0x059e783d.
//
// Solidity: function getGCnt() view returns(uint64)
func (_IGroupGetter *IGroupGetterCallerSession) GetGCnt() (uint64, error) {
	return _IGroupGetter.Contract.GetGCnt(&_IGroupGetter.CallOpts)
}

// GetGInfo is a free data retrieval call binding the contract method 0x38add6a1.
//
// Solidity: function getGInfo(uint64 i) view returns(bool, bool)
func (_IGroupGetter *IGroupGetterCaller) GetGInfo(opts *bind.CallOpts, i uint64) (bool, bool, error) {
	var out []interface{}
	err := _IGroupGetter.contract.Call(opts, &out, "getGInfo", i)

	if err != nil {
		return *new(bool), *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)
	out1 := *abi.ConvertType(out[1], new(bool)).(*bool)

	return out0, out1, err

}

// GetGInfo is a free data retrieval call binding the contract method 0x38add6a1.
//
// Solidity: function getGInfo(uint64 i) view returns(bool, bool)
func (_IGroupGetter *IGroupGetterSession) GetGInfo(i uint64) (bool, bool, error) {
	return _IGroupGetter.Contract.GetGInfo(&_IGroupGetter.CallOpts, i)
}

// GetGInfo is a free data retrieval call binding the contract method 0x38add6a1.
//
// Solidity: function getGInfo(uint64 i) view returns(bool, bool)
func (_IGroupGetter *IGroupGetterCallerSession) GetGInfo(i uint64) (bool, bool, error) {
	return _IGroupGetter.Contract.GetGInfo(&_IGroupGetter.CallOpts, i)
}

// GetKManage is a free data retrieval call binding the contract method 0x929629d2.
//
// Solidity: function getKManage(uint64 _i) view returns(address)
func (_IGroupGetter *IGroupGetterCaller) GetKManage(opts *bind.CallOpts, _i uint64) (common.Address, error) {
	var out []interface{}
	err := _IGroupGetter.contract.Call(opts, &out, "getKManage", _i)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetKManage is a free data retrieval call binding the contract method 0x929629d2.
//
// Solidity: function getKManage(uint64 _i) view returns(address)
func (_IGroupGetter *IGroupGetterSession) GetKManage(_i uint64) (common.Address, error) {
	return _IGroupGetter.Contract.GetKManage(&_IGroupGetter.CallOpts, _i)
}

// GetKManage is a free data retrieval call binding the contract method 0x929629d2.
//
// Solidity: function getKManage(uint64 _i) view returns(address)
func (_IGroupGetter *IGroupGetterCallerSession) GetKManage(_i uint64) (common.Address, error) {
	return _IGroupGetter.Contract.GetKManage(&_IGroupGetter.CallOpts, _i)
}

// GetLevel is a free data retrieval call binding the contract method 0x770609a8.
//
// Solidity: function getLevel(uint64 i) view returns(uint16)
func (_IGroupGetter *IGroupGetterCaller) GetLevel(opts *bind.CallOpts, i uint64) (uint16, error) {
	var out []interface{}
	err := _IGroupGetter.contract.Call(opts, &out, "getLevel", i)

	if err != nil {
		return *new(uint16), err
	}

	out0 := *abi.ConvertType(out[0], new(uint16)).(*uint16)

	return out0, err

}

// GetLevel is a free data retrieval call binding the contract method 0x770609a8.
//
// Solidity: function getLevel(uint64 i) view returns(uint16)
func (_IGroupGetter *IGroupGetterSession) GetLevel(i uint64) (uint16, error) {
	return _IGroupGetter.Contract.GetLevel(&_IGroupGetter.CallOpts, i)
}

// GetLevel is a free data retrieval call binding the contract method 0x770609a8.
//
// Solidity: function getLevel(uint64 i) view returns(uint16)
func (_IGroupGetter *IGroupGetterCallerSession) GetLevel(i uint64) (uint16, error) {
	return _IGroupGetter.Contract.GetLevel(&_IGroupGetter.CallOpts, i)
}

// GetPInfo is a free data retrieval call binding the contract method 0x50aa2329.
//
// Solidity: function getPInfo(uint64 _i) view returns(uint256, uint256)
func (_IGroupGetter *IGroupGetterCaller) GetPInfo(opts *bind.CallOpts, _i uint64) (*big.Int, *big.Int, error) {
	var out []interface{}
	err := _IGroupGetter.contract.Call(opts, &out, "getPInfo", _i)

	if err != nil {
		return *new(*big.Int), *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	out1 := *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)

	return out0, out1, err

}

// GetPInfo is a free data retrieval call binding the contract method 0x50aa2329.
//
// Solidity: function getPInfo(uint64 _i) view returns(uint256, uint256)
func (_IGroupGetter *IGroupGetterSession) GetPInfo(_i uint64) (*big.Int, *big.Int, error) {
	return _IGroupGetter.Contract.GetPInfo(&_IGroupGetter.CallOpts, _i)
}

// GetPInfo is a free data retrieval call binding the contract method 0x50aa2329.
//
// Solidity: function getPInfo(uint64 _i) view returns(uint256, uint256)
func (_IGroupGetter *IGroupGetterCallerSession) GetPInfo(_i uint64) (*big.Int, *big.Int, error) {
	return _IGroupGetter.Contract.GetPInfo(&_IGroupGetter.CallOpts, _i)
}

// GetSStra is a free data retrieval call binding the contract method 0xdc698953.
//
// Solidity: function getSStra(uint64 i) view returns(uint8, uint8)
func (_IGroupGetter *IGroupGetterCaller) GetSStra(opts *bind.CallOpts, i uint64) (uint8, uint8, error) {
	var out []interface{}
	err := _IGroupGetter.contract.Call(opts, &out, "getSStra", i)

	if err != nil {
		return *new(uint8), *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)
	out1 := *abi.ConvertType(out[1], new(uint8)).(*uint8)

	return out0, out1, err

}

// GetSStra is a free data retrieval call binding the contract method 0xdc698953.
//
// Solidity: function getSStra(uint64 i) view returns(uint8, uint8)
func (_IGroupGetter *IGroupGetterSession) GetSStra(i uint64) (uint8, uint8, error) {
	return _IGroupGetter.Contract.GetSStra(&_IGroupGetter.CallOpts, i)
}

// GetSStra is a free data retrieval call binding the contract method 0xdc698953.
//
// Solidity: function getSStra(uint64 i) view returns(uint8, uint8)
func (_IGroupGetter *IGroupGetterCallerSession) GetSStra(i uint64) (uint8, uint8, error) {
	return _IGroupGetter.Contract.GetSStra(&_IGroupGetter.CallOpts, i)
}

// IInstanceABI is the input ABI used to generate the binding from.
const IInstanceABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Alter\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"instances\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// IInstanceFuncSigs maps the 4-byte function signature to its string representation.
var IInstanceFuncSigs = map[string]string{
	"3ec7d5b9": "instances(uint8)",
}

// IInstance is an auto generated Go binding around an Ethereum contract.
type IInstance struct {
	IInstanceCaller     // Read-only binding to the contract
	IInstanceTransactor // Write-only binding to the contract
	IInstanceFilterer   // Log filterer for contract events
}

// IInstanceCaller is an auto generated read-only Go binding around an Ethereum contract.
type IInstanceCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IInstanceTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IInstanceTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IInstanceFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IInstanceFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IInstanceSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IInstanceSession struct {
	Contract     *IInstance        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IInstanceCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IInstanceCallerSession struct {
	Contract *IInstanceCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// IInstanceTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IInstanceTransactorSession struct {
	Contract     *IInstanceTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// IInstanceRaw is an auto generated low-level Go binding around an Ethereum contract.
type IInstanceRaw struct {
	Contract *IInstance // Generic contract binding to access the raw methods on
}

// IInstanceCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IInstanceCallerRaw struct {
	Contract *IInstanceCaller // Generic read-only contract binding to access the raw methods on
}

// IInstanceTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IInstanceTransactorRaw struct {
	Contract *IInstanceTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIInstance creates a new instance of IInstance, bound to a specific deployed contract.
func NewIInstance(address common.Address, backend bind.ContractBackend) (*IInstance, error) {
	contract, err := bindIInstance(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IInstance{IInstanceCaller: IInstanceCaller{contract: contract}, IInstanceTransactor: IInstanceTransactor{contract: contract}, IInstanceFilterer: IInstanceFilterer{contract: contract}}, nil
}

// NewIInstanceCaller creates a new read-only instance of IInstance, bound to a specific deployed contract.
func NewIInstanceCaller(address common.Address, caller bind.ContractCaller) (*IInstanceCaller, error) {
	contract, err := bindIInstance(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IInstanceCaller{contract: contract}, nil
}

// NewIInstanceTransactor creates a new write-only instance of IInstance, bound to a specific deployed contract.
func NewIInstanceTransactor(address common.Address, transactor bind.ContractTransactor) (*IInstanceTransactor, error) {
	contract, err := bindIInstance(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IInstanceTransactor{contract: contract}, nil
}

// NewIInstanceFilterer creates a new log filterer instance of IInstance, bound to a specific deployed contract.
func NewIInstanceFilterer(address common.Address, filterer bind.ContractFilterer) (*IInstanceFilterer, error) {
	contract, err := bindIInstance(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IInstanceFilterer{contract: contract}, nil
}

// bindIInstance binds a generic wrapper to an already deployed contract.
func bindIInstance(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IInstanceABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IInstance *IInstanceRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IInstance.Contract.IInstanceCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IInstance *IInstanceRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IInstance.Contract.IInstanceTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IInstance *IInstanceRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IInstance.Contract.IInstanceTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IInstance *IInstanceCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IInstance.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IInstance *IInstanceTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IInstance.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IInstance *IInstanceTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IInstance.Contract.contract.Transact(opts, method, params...)
}

// Instances is a free data retrieval call binding the contract method 0x3ec7d5b9.
//
// Solidity: function instances(uint8 _type) view returns(address)
func (_IInstance *IInstanceCaller) Instances(opts *bind.CallOpts, _type uint8) (common.Address, error) {
	var out []interface{}
	err := _IInstance.contract.Call(opts, &out, "instances", _type)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Instances is a free data retrieval call binding the contract method 0x3ec7d5b9.
//
// Solidity: function instances(uint8 _type) view returns(address)
func (_IInstance *IInstanceSession) Instances(_type uint8) (common.Address, error) {
	return _IInstance.Contract.Instances(&_IInstance.CallOpts, _type)
}

// Instances is a free data retrieval call binding the contract method 0x3ec7d5b9.
//
// Solidity: function instances(uint8 _type) view returns(address)
func (_IInstance *IInstanceCallerSession) Instances(_type uint8) (common.Address, error) {
	return _IInstance.Contract.Instances(&_IInstance.CallOpts, _type)
}

// IInstanceAlterIterator is returned from FilterAlter and is used to iterate over the raw logs and unpacked data for Alter events raised by the IInstance contract.
type IInstanceAlterIterator struct {
	Event *IInstanceAlter // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IInstanceAlterIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IInstanceAlter)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IInstanceAlter)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IInstanceAlterIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IInstanceAlterIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IInstanceAlter represents a Alter event raised by the IInstance contract.
type IInstanceAlter struct {
	Type uint8
	From common.Address
	To   common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterAlter is a free log retrieval operation binding the contract event 0x69da8aaa18d0d64ebdd4d982e4d32ac4aaab1fe0c1034b19846e51a61fcc0f02.
//
// Solidity: event Alter(uint8 _type, address from, address to)
func (_IInstance *IInstanceFilterer) FilterAlter(opts *bind.FilterOpts) (*IInstanceAlterIterator, error) {

	logs, sub, err := _IInstance.contract.FilterLogs(opts, "Alter")
	if err != nil {
		return nil, err
	}
	return &IInstanceAlterIterator{contract: _IInstance.contract, event: "Alter", logs: logs, sub: sub}, nil
}

// WatchAlter is a free log subscription operation binding the contract event 0x69da8aaa18d0d64ebdd4d982e4d32ac4aaab1fe0c1034b19846e51a61fcc0f02.
//
// Solidity: event Alter(uint8 _type, address from, address to)
func (_IInstance *IInstanceFilterer) WatchAlter(opts *bind.WatchOpts, sink chan<- *IInstanceAlter) (event.Subscription, error) {

	logs, sub, err := _IInstance.contract.WatchLogs(opts, "Alter")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IInstanceAlter)
				if err := _IInstance.contract.UnpackLog(event, "Alter", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAlter is a log parse operation binding the contract event 0x69da8aaa18d0d64ebdd4d982e4d32ac4aaab1fe0c1034b19846e51a61fcc0f02.
//
// Solidity: event Alter(uint8 _type, address from, address to)
func (_IInstance *IInstanceFilterer) ParseAlter(log types.Log) (*IInstanceAlter, error) {
	event := new(IInstanceAlter)
	if err := _IInstance.contract.UnpackLog(event, "Alter", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IIssuanceABI is the input ABI used to generate the binding from.
const IIssuanceABI = "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_end\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_size\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_sPrice\",\"type\":\"uint256\"}],\"name\":\"issu\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IIssuanceFuncSigs maps the 4-byte function signature to its string representation.
var IIssuanceFuncSigs = map[string]string{
	"13df3828": "issu(uint64,uint64,uint64,uint256)",
}

// IIssuance is an auto generated Go binding around an Ethereum contract.
type IIssuance struct {
	IIssuanceCaller     // Read-only binding to the contract
	IIssuanceTransactor // Write-only binding to the contract
	IIssuanceFilterer   // Log filterer for contract events
}

// IIssuanceCaller is an auto generated read-only Go binding around an Ethereum contract.
type IIssuanceCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IIssuanceTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IIssuanceTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IIssuanceFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IIssuanceFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IIssuanceSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IIssuanceSession struct {
	Contract     *IIssuance        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IIssuanceCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IIssuanceCallerSession struct {
	Contract *IIssuanceCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// IIssuanceTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IIssuanceTransactorSession struct {
	Contract     *IIssuanceTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// IIssuanceRaw is an auto generated low-level Go binding around an Ethereum contract.
type IIssuanceRaw struct {
	Contract *IIssuance // Generic contract binding to access the raw methods on
}

// IIssuanceCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IIssuanceCallerRaw struct {
	Contract *IIssuanceCaller // Generic read-only contract binding to access the raw methods on
}

// IIssuanceTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IIssuanceTransactorRaw struct {
	Contract *IIssuanceTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIIssuance creates a new instance of IIssuance, bound to a specific deployed contract.
func NewIIssuance(address common.Address, backend bind.ContractBackend) (*IIssuance, error) {
	contract, err := bindIIssuance(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IIssuance{IIssuanceCaller: IIssuanceCaller{contract: contract}, IIssuanceTransactor: IIssuanceTransactor{contract: contract}, IIssuanceFilterer: IIssuanceFilterer{contract: contract}}, nil
}

// NewIIssuanceCaller creates a new read-only instance of IIssuance, bound to a specific deployed contract.
func NewIIssuanceCaller(address common.Address, caller bind.ContractCaller) (*IIssuanceCaller, error) {
	contract, err := bindIIssuance(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IIssuanceCaller{contract: contract}, nil
}

// NewIIssuanceTransactor creates a new write-only instance of IIssuance, bound to a specific deployed contract.
func NewIIssuanceTransactor(address common.Address, transactor bind.ContractTransactor) (*IIssuanceTransactor, error) {
	contract, err := bindIIssuance(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IIssuanceTransactor{contract: contract}, nil
}

// NewIIssuanceFilterer creates a new log filterer instance of IIssuance, bound to a specific deployed contract.
func NewIIssuanceFilterer(address common.Address, filterer bind.ContractFilterer) (*IIssuanceFilterer, error) {
	contract, err := bindIIssuance(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IIssuanceFilterer{contract: contract}, nil
}

// bindIIssuance binds a generic wrapper to an already deployed contract.
func bindIIssuance(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IIssuanceABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IIssuance *IIssuanceRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IIssuance.Contract.IIssuanceCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IIssuance *IIssuanceRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IIssuance.Contract.IIssuanceTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IIssuance *IIssuanceRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IIssuance.Contract.IIssuanceTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IIssuance *IIssuanceCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IIssuance.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IIssuance *IIssuanceTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IIssuance.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IIssuance *IIssuanceTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IIssuance.Contract.contract.Transact(opts, method, params...)
}

// Issu is a paid mutator transaction binding the contract method 0x13df3828.
//
// Solidity: function issu(uint64 _start, uint64 _end, uint64 _size, uint256 _sPrice) returns(uint256)
func (_IIssuance *IIssuanceTransactor) Issu(opts *bind.TransactOpts, _start uint64, _end uint64, _size uint64, _sPrice *big.Int) (*types.Transaction, error) {
	return _IIssuance.contract.Transact(opts, "issu", _start, _end, _size, _sPrice)
}

// Issu is a paid mutator transaction binding the contract method 0x13df3828.
//
// Solidity: function issu(uint64 _start, uint64 _end, uint64 _size, uint256 _sPrice) returns(uint256)
func (_IIssuance *IIssuanceSession) Issu(_start uint64, _end uint64, _size uint64, _sPrice *big.Int) (*types.Transaction, error) {
	return _IIssuance.Contract.Issu(&_IIssuance.TransactOpts, _start, _end, _size, _sPrice)
}

// Issu is a paid mutator transaction binding the contract method 0x13df3828.
//
// Solidity: function issu(uint64 _start, uint64 _end, uint64 _size, uint256 _sPrice) returns(uint256)
func (_IIssuance *IIssuanceTransactorSession) Issu(_start uint64, _end uint64, _size uint64, _sPrice *big.Int) (*types.Transaction, error) {
	return _IIssuance.Contract.Issu(&_IIssuance.TransactOpts, _start, _end, _size, _sPrice)
}

// IKmanageABI is the input ABI used to generate the binding from.
const IKmanageABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"ki\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"cnt\",\"type\":\"uint64\"}],\"name\":\"AddCnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"ti\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"AddProfit\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_ki\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_cnt\",\"type\":\"uint64\"}],\"name\":\"addCnt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_ki\",\"type\":\"uint64\"}],\"name\":\"addKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_money\",\"type\":\"uint256\"}],\"name\":\"addProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_ki\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_i\",\"type\":\"uint64\"}],\"name\":\"getK\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getKCnt\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"}],\"name\":\"getPf\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manageRate\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_ki\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IKmanageFuncSigs maps the 4-byte function signature to its string representation.
var IKmanageFuncSigs = map[string]string{
	"024130e4": "addCnt(uint64,uint64)",
	"50cbb46f": "addKeeper(uint64)",
	"55d3d7ef": "addProfit(uint8,uint256)",
	"fc3ba0ad": "balanceOf(uint64,uint8)",
	"dc0e7f45": "getK(uint64)",
	"39f2db96": "getKCnt()",
	"4f3c2eab": "getPf(uint8)",
	"6d23f6c8": "manageRate()",
	"259c6d5e": "withdraw(uint64,uint8,uint256)",
}

// IKmanage is an auto generated Go binding around an Ethereum contract.
type IKmanage struct {
	IKmanageCaller     // Read-only binding to the contract
	IKmanageTransactor // Write-only binding to the contract
	IKmanageFilterer   // Log filterer for contract events
}

// IKmanageCaller is an auto generated read-only Go binding around an Ethereum contract.
type IKmanageCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IKmanageTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IKmanageTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IKmanageFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IKmanageFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IKmanageSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IKmanageSession struct {
	Contract     *IKmanage         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IKmanageCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IKmanageCallerSession struct {
	Contract *IKmanageCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// IKmanageTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IKmanageTransactorSession struct {
	Contract     *IKmanageTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// IKmanageRaw is an auto generated low-level Go binding around an Ethereum contract.
type IKmanageRaw struct {
	Contract *IKmanage // Generic contract binding to access the raw methods on
}

// IKmanageCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IKmanageCallerRaw struct {
	Contract *IKmanageCaller // Generic read-only contract binding to access the raw methods on
}

// IKmanageTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IKmanageTransactorRaw struct {
	Contract *IKmanageTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIKmanage creates a new instance of IKmanage, bound to a specific deployed contract.
func NewIKmanage(address common.Address, backend bind.ContractBackend) (*IKmanage, error) {
	contract, err := bindIKmanage(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IKmanage{IKmanageCaller: IKmanageCaller{contract: contract}, IKmanageTransactor: IKmanageTransactor{contract: contract}, IKmanageFilterer: IKmanageFilterer{contract: contract}}, nil
}

// NewIKmanageCaller creates a new read-only instance of IKmanage, bound to a specific deployed contract.
func NewIKmanageCaller(address common.Address, caller bind.ContractCaller) (*IKmanageCaller, error) {
	contract, err := bindIKmanage(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IKmanageCaller{contract: contract}, nil
}

// NewIKmanageTransactor creates a new write-only instance of IKmanage, bound to a specific deployed contract.
func NewIKmanageTransactor(address common.Address, transactor bind.ContractTransactor) (*IKmanageTransactor, error) {
	contract, err := bindIKmanage(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IKmanageTransactor{contract: contract}, nil
}

// NewIKmanageFilterer creates a new log filterer instance of IKmanage, bound to a specific deployed contract.
func NewIKmanageFilterer(address common.Address, filterer bind.ContractFilterer) (*IKmanageFilterer, error) {
	contract, err := bindIKmanage(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IKmanageFilterer{contract: contract}, nil
}

// bindIKmanage binds a generic wrapper to an already deployed contract.
func bindIKmanage(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IKmanageABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IKmanage *IKmanageRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IKmanage.Contract.IKmanageCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IKmanage *IKmanageRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IKmanage.Contract.IKmanageTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IKmanage *IKmanageRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IKmanage.Contract.IKmanageTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IKmanage *IKmanageCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IKmanage.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IKmanage *IKmanageTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IKmanage.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IKmanage *IKmanageTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IKmanage.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0xfc3ba0ad.
//
// Solidity: function balanceOf(uint64 _ki, uint8 _ti) view returns(uint256, uint256)
func (_IKmanage *IKmanageCaller) BalanceOf(opts *bind.CallOpts, _ki uint64, _ti uint8) (*big.Int, *big.Int, error) {
	var out []interface{}
	err := _IKmanage.contract.Call(opts, &out, "balanceOf", _ki, _ti)

	if err != nil {
		return *new(*big.Int), *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	out1 := *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)

	return out0, out1, err

}

// BalanceOf is a free data retrieval call binding the contract method 0xfc3ba0ad.
//
// Solidity: function balanceOf(uint64 _ki, uint8 _ti) view returns(uint256, uint256)
func (_IKmanage *IKmanageSession) BalanceOf(_ki uint64, _ti uint8) (*big.Int, *big.Int, error) {
	return _IKmanage.Contract.BalanceOf(&_IKmanage.CallOpts, _ki, _ti)
}

// BalanceOf is a free data retrieval call binding the contract method 0xfc3ba0ad.
//
// Solidity: function balanceOf(uint64 _ki, uint8 _ti) view returns(uint256, uint256)
func (_IKmanage *IKmanageCallerSession) BalanceOf(_ki uint64, _ti uint8) (*big.Int, *big.Int, error) {
	return _IKmanage.Contract.BalanceOf(&_IKmanage.CallOpts, _ki, _ti)
}

// GetK is a free data retrieval call binding the contract method 0xdc0e7f45.
//
// Solidity: function getK(uint64 _i) view returns(uint64)
func (_IKmanage *IKmanageCaller) GetK(opts *bind.CallOpts, _i uint64) (uint64, error) {
	var out []interface{}
	err := _IKmanage.contract.Call(opts, &out, "getK", _i)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// GetK is a free data retrieval call binding the contract method 0xdc0e7f45.
//
// Solidity: function getK(uint64 _i) view returns(uint64)
func (_IKmanage *IKmanageSession) GetK(_i uint64) (uint64, error) {
	return _IKmanage.Contract.GetK(&_IKmanage.CallOpts, _i)
}

// GetK is a free data retrieval call binding the contract method 0xdc0e7f45.
//
// Solidity: function getK(uint64 _i) view returns(uint64)
func (_IKmanage *IKmanageCallerSession) GetK(_i uint64) (uint64, error) {
	return _IKmanage.Contract.GetK(&_IKmanage.CallOpts, _i)
}

// GetKCnt is a free data retrieval call binding the contract method 0x39f2db96.
//
// Solidity: function getKCnt() view returns(uint8)
func (_IKmanage *IKmanageCaller) GetKCnt(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _IKmanage.contract.Call(opts, &out, "getKCnt")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// GetKCnt is a free data retrieval call binding the contract method 0x39f2db96.
//
// Solidity: function getKCnt() view returns(uint8)
func (_IKmanage *IKmanageSession) GetKCnt() (uint8, error) {
	return _IKmanage.Contract.GetKCnt(&_IKmanage.CallOpts)
}

// GetKCnt is a free data retrieval call binding the contract method 0x39f2db96.
//
// Solidity: function getKCnt() view returns(uint8)
func (_IKmanage *IKmanageCallerSession) GetKCnt() (uint8, error) {
	return _IKmanage.Contract.GetKCnt(&_IKmanage.CallOpts)
}

// GetPf is a free data retrieval call binding the contract method 0x4f3c2eab.
//
// Solidity: function getPf(uint8 _ti) view returns(uint64, uint256)
func (_IKmanage *IKmanageCaller) GetPf(opts *bind.CallOpts, _ti uint8) (uint64, *big.Int, error) {
	var out []interface{}
	err := _IKmanage.contract.Call(opts, &out, "getPf", _ti)

	if err != nil {
		return *new(uint64), *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)
	out1 := *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)

	return out0, out1, err

}

// GetPf is a free data retrieval call binding the contract method 0x4f3c2eab.
//
// Solidity: function getPf(uint8 _ti) view returns(uint64, uint256)
func (_IKmanage *IKmanageSession) GetPf(_ti uint8) (uint64, *big.Int, error) {
	return _IKmanage.Contract.GetPf(&_IKmanage.CallOpts, _ti)
}

// GetPf is a free data retrieval call binding the contract method 0x4f3c2eab.
//
// Solidity: function getPf(uint8 _ti) view returns(uint64, uint256)
func (_IKmanage *IKmanageCallerSession) GetPf(_ti uint8) (uint64, *big.Int, error) {
	return _IKmanage.Contract.GetPf(&_IKmanage.CallOpts, _ti)
}

// ManageRate is a free data retrieval call binding the contract method 0x6d23f6c8.
//
// Solidity: function manageRate() view returns(uint8)
func (_IKmanage *IKmanageCaller) ManageRate(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _IKmanage.contract.Call(opts, &out, "manageRate")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ManageRate is a free data retrieval call binding the contract method 0x6d23f6c8.
//
// Solidity: function manageRate() view returns(uint8)
func (_IKmanage *IKmanageSession) ManageRate() (uint8, error) {
	return _IKmanage.Contract.ManageRate(&_IKmanage.CallOpts)
}

// ManageRate is a free data retrieval call binding the contract method 0x6d23f6c8.
//
// Solidity: function manageRate() view returns(uint8)
func (_IKmanage *IKmanageCallerSession) ManageRate() (uint8, error) {
	return _IKmanage.Contract.ManageRate(&_IKmanage.CallOpts)
}

// AddCnt is a paid mutator transaction binding the contract method 0x024130e4.
//
// Solidity: function addCnt(uint64 _ki, uint64 _cnt) returns()
func (_IKmanage *IKmanageTransactor) AddCnt(opts *bind.TransactOpts, _ki uint64, _cnt uint64) (*types.Transaction, error) {
	return _IKmanage.contract.Transact(opts, "addCnt", _ki, _cnt)
}

// AddCnt is a paid mutator transaction binding the contract method 0x024130e4.
//
// Solidity: function addCnt(uint64 _ki, uint64 _cnt) returns()
func (_IKmanage *IKmanageSession) AddCnt(_ki uint64, _cnt uint64) (*types.Transaction, error) {
	return _IKmanage.Contract.AddCnt(&_IKmanage.TransactOpts, _ki, _cnt)
}

// AddCnt is a paid mutator transaction binding the contract method 0x024130e4.
//
// Solidity: function addCnt(uint64 _ki, uint64 _cnt) returns()
func (_IKmanage *IKmanageTransactorSession) AddCnt(_ki uint64, _cnt uint64) (*types.Transaction, error) {
	return _IKmanage.Contract.AddCnt(&_IKmanage.TransactOpts, _ki, _cnt)
}

// AddKeeper is a paid mutator transaction binding the contract method 0x50cbb46f.
//
// Solidity: function addKeeper(uint64 _ki) returns()
func (_IKmanage *IKmanageTransactor) AddKeeper(opts *bind.TransactOpts, _ki uint64) (*types.Transaction, error) {
	return _IKmanage.contract.Transact(opts, "addKeeper", _ki)
}

// AddKeeper is a paid mutator transaction binding the contract method 0x50cbb46f.
//
// Solidity: function addKeeper(uint64 _ki) returns()
func (_IKmanage *IKmanageSession) AddKeeper(_ki uint64) (*types.Transaction, error) {
	return _IKmanage.Contract.AddKeeper(&_IKmanage.TransactOpts, _ki)
}

// AddKeeper is a paid mutator transaction binding the contract method 0x50cbb46f.
//
// Solidity: function addKeeper(uint64 _ki) returns()
func (_IKmanage *IKmanageTransactorSession) AddKeeper(_ki uint64) (*types.Transaction, error) {
	return _IKmanage.Contract.AddKeeper(&_IKmanage.TransactOpts, _ki)
}

// AddProfit is a paid mutator transaction binding the contract method 0x55d3d7ef.
//
// Solidity: function addProfit(uint8 _ti, uint256 _money) returns()
func (_IKmanage *IKmanageTransactor) AddProfit(opts *bind.TransactOpts, _ti uint8, _money *big.Int) (*types.Transaction, error) {
	return _IKmanage.contract.Transact(opts, "addProfit", _ti, _money)
}

// AddProfit is a paid mutator transaction binding the contract method 0x55d3d7ef.
//
// Solidity: function addProfit(uint8 _ti, uint256 _money) returns()
func (_IKmanage *IKmanageSession) AddProfit(_ti uint8, _money *big.Int) (*types.Transaction, error) {
	return _IKmanage.Contract.AddProfit(&_IKmanage.TransactOpts, _ti, _money)
}

// AddProfit is a paid mutator transaction binding the contract method 0x55d3d7ef.
//
// Solidity: function addProfit(uint8 _ti, uint256 _money) returns()
func (_IKmanage *IKmanageTransactorSession) AddProfit(_ti uint8, _money *big.Int) (*types.Transaction, error) {
	return _IKmanage.Contract.AddProfit(&_IKmanage.TransactOpts, _ti, _money)
}

// Withdraw is a paid mutator transaction binding the contract method 0x259c6d5e.
//
// Solidity: function withdraw(uint64 _ki, uint8 _ti, uint256 money) returns(uint256)
func (_IKmanage *IKmanageTransactor) Withdraw(opts *bind.TransactOpts, _ki uint64, _ti uint8, money *big.Int) (*types.Transaction, error) {
	return _IKmanage.contract.Transact(opts, "withdraw", _ki, _ti, money)
}

// Withdraw is a paid mutator transaction binding the contract method 0x259c6d5e.
//
// Solidity: function withdraw(uint64 _ki, uint8 _ti, uint256 money) returns(uint256)
func (_IKmanage *IKmanageSession) Withdraw(_ki uint64, _ti uint8, money *big.Int) (*types.Transaction, error) {
	return _IKmanage.Contract.Withdraw(&_IKmanage.TransactOpts, _ki, _ti, money)
}

// Withdraw is a paid mutator transaction binding the contract method 0x259c6d5e.
//
// Solidity: function withdraw(uint64 _ki, uint8 _ti, uint256 money) returns(uint256)
func (_IKmanage *IKmanageTransactorSession) Withdraw(_ki uint64, _ti uint8, money *big.Int) (*types.Transaction, error) {
	return _IKmanage.Contract.Withdraw(&_IKmanage.TransactOpts, _ki, _ti, money)
}

// IKmanageAddCntIterator is returned from FilterAddCnt and is used to iterate over the raw logs and unpacked data for AddCnt events raised by the IKmanage contract.
type IKmanageAddCntIterator struct {
	Event *IKmanageAddCnt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IKmanageAddCntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IKmanageAddCnt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IKmanageAddCnt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IKmanageAddCntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IKmanageAddCntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IKmanageAddCnt represents a AddCnt event raised by the IKmanage contract.
type IKmanageAddCnt struct {
	Ki  uint64
	Cnt uint64
	Raw types.Log // Blockchain specific contextual infos
}

// FilterAddCnt is a free log retrieval operation binding the contract event 0x5372d6aad551334f508508499c71755ebc6cde46b83fc1f944f1f0ae33cbb4c4.
//
// Solidity: event AddCnt(uint64 indexed ki, uint64 cnt)
func (_IKmanage *IKmanageFilterer) FilterAddCnt(opts *bind.FilterOpts, ki []uint64) (*IKmanageAddCntIterator, error) {

	var kiRule []interface{}
	for _, kiItem := range ki {
		kiRule = append(kiRule, kiItem)
	}

	logs, sub, err := _IKmanage.contract.FilterLogs(opts, "AddCnt", kiRule)
	if err != nil {
		return nil, err
	}
	return &IKmanageAddCntIterator{contract: _IKmanage.contract, event: "AddCnt", logs: logs, sub: sub}, nil
}

// WatchAddCnt is a free log subscription operation binding the contract event 0x5372d6aad551334f508508499c71755ebc6cde46b83fc1f944f1f0ae33cbb4c4.
//
// Solidity: event AddCnt(uint64 indexed ki, uint64 cnt)
func (_IKmanage *IKmanageFilterer) WatchAddCnt(opts *bind.WatchOpts, sink chan<- *IKmanageAddCnt, ki []uint64) (event.Subscription, error) {

	var kiRule []interface{}
	for _, kiItem := range ki {
		kiRule = append(kiRule, kiItem)
	}

	logs, sub, err := _IKmanage.contract.WatchLogs(opts, "AddCnt", kiRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IKmanageAddCnt)
				if err := _IKmanage.contract.UnpackLog(event, "AddCnt", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddCnt is a log parse operation binding the contract event 0x5372d6aad551334f508508499c71755ebc6cde46b83fc1f944f1f0ae33cbb4c4.
//
// Solidity: event AddCnt(uint64 indexed ki, uint64 cnt)
func (_IKmanage *IKmanageFilterer) ParseAddCnt(log types.Log) (*IKmanageAddCnt, error) {
	event := new(IKmanageAddCnt)
	if err := _IKmanage.contract.UnpackLog(event, "AddCnt", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IKmanageAddProfitIterator is returned from FilterAddProfit and is used to iterate over the raw logs and unpacked data for AddProfit events raised by the IKmanage contract.
type IKmanageAddProfitIterator struct {
	Event *IKmanageAddProfit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IKmanageAddProfitIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IKmanageAddProfit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IKmanageAddProfit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IKmanageAddProfitIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IKmanageAddProfitIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IKmanageAddProfit represents a AddProfit event raised by the IKmanage contract.
type IKmanageAddProfit struct {
	Ti    uint8
	Money *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterAddProfit is a free log retrieval operation binding the contract event 0xe5fd8ec20bdfeb1fadd32ec3786545a1db18d74f952effda5c6cd50af7c2e9e8.
//
// Solidity: event AddProfit(uint8 indexed ti, uint256 money)
func (_IKmanage *IKmanageFilterer) FilterAddProfit(opts *bind.FilterOpts, ti []uint8) (*IKmanageAddProfitIterator, error) {

	var tiRule []interface{}
	for _, tiItem := range ti {
		tiRule = append(tiRule, tiItem)
	}

	logs, sub, err := _IKmanage.contract.FilterLogs(opts, "AddProfit", tiRule)
	if err != nil {
		return nil, err
	}
	return &IKmanageAddProfitIterator{contract: _IKmanage.contract, event: "AddProfit", logs: logs, sub: sub}, nil
}

// WatchAddProfit is a free log subscription operation binding the contract event 0xe5fd8ec20bdfeb1fadd32ec3786545a1db18d74f952effda5c6cd50af7c2e9e8.
//
// Solidity: event AddProfit(uint8 indexed ti, uint256 money)
func (_IKmanage *IKmanageFilterer) WatchAddProfit(opts *bind.WatchOpts, sink chan<- *IKmanageAddProfit, ti []uint8) (event.Subscription, error) {

	var tiRule []interface{}
	for _, tiItem := range ti {
		tiRule = append(tiRule, tiItem)
	}

	logs, sub, err := _IKmanage.contract.WatchLogs(opts, "AddProfit", tiRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IKmanageAddProfit)
				if err := _IKmanage.contract.UnpackLog(event, "AddProfit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddProfit is a log parse operation binding the contract event 0xe5fd8ec20bdfeb1fadd32ec3786545a1db18d74f952effda5c6cd50af7c2e9e8.
//
// Solidity: event AddProfit(uint8 indexed ti, uint256 money)
func (_IKmanage *IKmanageFilterer) ParseAddProfit(log types.Log) (*IKmanageAddProfit, error) {
	event := new(IKmanageAddProfit)
	if err := _IKmanage.contract.UnpackLog(event, "AddProfit", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IKmanageGetterABI is the input ABI used to generate the binding from.
const IKmanageGetterABI = "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_ki\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_i\",\"type\":\"uint64\"}],\"name\":\"getK\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getKCnt\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"}],\"name\":\"getPf\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manageRate\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// IKmanageGetterFuncSigs maps the 4-byte function signature to its string representation.
var IKmanageGetterFuncSigs = map[string]string{
	"fc3ba0ad": "balanceOf(uint64,uint8)",
	"dc0e7f45": "getK(uint64)",
	"39f2db96": "getKCnt()",
	"4f3c2eab": "getPf(uint8)",
	"6d23f6c8": "manageRate()",
}

// IKmanageGetter is an auto generated Go binding around an Ethereum contract.
type IKmanageGetter struct {
	IKmanageGetterCaller     // Read-only binding to the contract
	IKmanageGetterTransactor // Write-only binding to the contract
	IKmanageGetterFilterer   // Log filterer for contract events
}

// IKmanageGetterCaller is an auto generated read-only Go binding around an Ethereum contract.
type IKmanageGetterCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IKmanageGetterTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IKmanageGetterTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IKmanageGetterFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IKmanageGetterFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IKmanageGetterSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IKmanageGetterSession struct {
	Contract     *IKmanageGetter   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IKmanageGetterCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IKmanageGetterCallerSession struct {
	Contract *IKmanageGetterCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IKmanageGetterTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IKmanageGetterTransactorSession struct {
	Contract     *IKmanageGetterTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IKmanageGetterRaw is an auto generated low-level Go binding around an Ethereum contract.
type IKmanageGetterRaw struct {
	Contract *IKmanageGetter // Generic contract binding to access the raw methods on
}

// IKmanageGetterCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IKmanageGetterCallerRaw struct {
	Contract *IKmanageGetterCaller // Generic read-only contract binding to access the raw methods on
}

// IKmanageGetterTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IKmanageGetterTransactorRaw struct {
	Contract *IKmanageGetterTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIKmanageGetter creates a new instance of IKmanageGetter, bound to a specific deployed contract.
func NewIKmanageGetter(address common.Address, backend bind.ContractBackend) (*IKmanageGetter, error) {
	contract, err := bindIKmanageGetter(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IKmanageGetter{IKmanageGetterCaller: IKmanageGetterCaller{contract: contract}, IKmanageGetterTransactor: IKmanageGetterTransactor{contract: contract}, IKmanageGetterFilterer: IKmanageGetterFilterer{contract: contract}}, nil
}

// NewIKmanageGetterCaller creates a new read-only instance of IKmanageGetter, bound to a specific deployed contract.
func NewIKmanageGetterCaller(address common.Address, caller bind.ContractCaller) (*IKmanageGetterCaller, error) {
	contract, err := bindIKmanageGetter(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IKmanageGetterCaller{contract: contract}, nil
}

// NewIKmanageGetterTransactor creates a new write-only instance of IKmanageGetter, bound to a specific deployed contract.
func NewIKmanageGetterTransactor(address common.Address, transactor bind.ContractTransactor) (*IKmanageGetterTransactor, error) {
	contract, err := bindIKmanageGetter(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IKmanageGetterTransactor{contract: contract}, nil
}

// NewIKmanageGetterFilterer creates a new log filterer instance of IKmanageGetter, bound to a specific deployed contract.
func NewIKmanageGetterFilterer(address common.Address, filterer bind.ContractFilterer) (*IKmanageGetterFilterer, error) {
	contract, err := bindIKmanageGetter(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IKmanageGetterFilterer{contract: contract}, nil
}

// bindIKmanageGetter binds a generic wrapper to an already deployed contract.
func bindIKmanageGetter(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IKmanageGetterABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IKmanageGetter *IKmanageGetterRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IKmanageGetter.Contract.IKmanageGetterCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IKmanageGetter *IKmanageGetterRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IKmanageGetter.Contract.IKmanageGetterTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IKmanageGetter *IKmanageGetterRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IKmanageGetter.Contract.IKmanageGetterTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IKmanageGetter *IKmanageGetterCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IKmanageGetter.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IKmanageGetter *IKmanageGetterTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IKmanageGetter.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IKmanageGetter *IKmanageGetterTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IKmanageGetter.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0xfc3ba0ad.
//
// Solidity: function balanceOf(uint64 _ki, uint8 _ti) view returns(uint256, uint256)
func (_IKmanageGetter *IKmanageGetterCaller) BalanceOf(opts *bind.CallOpts, _ki uint64, _ti uint8) (*big.Int, *big.Int, error) {
	var out []interface{}
	err := _IKmanageGetter.contract.Call(opts, &out, "balanceOf", _ki, _ti)

	if err != nil {
		return *new(*big.Int), *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	out1 := *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)

	return out0, out1, err

}

// BalanceOf is a free data retrieval call binding the contract method 0xfc3ba0ad.
//
// Solidity: function balanceOf(uint64 _ki, uint8 _ti) view returns(uint256, uint256)
func (_IKmanageGetter *IKmanageGetterSession) BalanceOf(_ki uint64, _ti uint8) (*big.Int, *big.Int, error) {
	return _IKmanageGetter.Contract.BalanceOf(&_IKmanageGetter.CallOpts, _ki, _ti)
}

// BalanceOf is a free data retrieval call binding the contract method 0xfc3ba0ad.
//
// Solidity: function balanceOf(uint64 _ki, uint8 _ti) view returns(uint256, uint256)
func (_IKmanageGetter *IKmanageGetterCallerSession) BalanceOf(_ki uint64, _ti uint8) (*big.Int, *big.Int, error) {
	return _IKmanageGetter.Contract.BalanceOf(&_IKmanageGetter.CallOpts, _ki, _ti)
}

// GetK is a free data retrieval call binding the contract method 0xdc0e7f45.
//
// Solidity: function getK(uint64 _i) view returns(uint64)
func (_IKmanageGetter *IKmanageGetterCaller) GetK(opts *bind.CallOpts, _i uint64) (uint64, error) {
	var out []interface{}
	err := _IKmanageGetter.contract.Call(opts, &out, "getK", _i)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// GetK is a free data retrieval call binding the contract method 0xdc0e7f45.
//
// Solidity: function getK(uint64 _i) view returns(uint64)
func (_IKmanageGetter *IKmanageGetterSession) GetK(_i uint64) (uint64, error) {
	return _IKmanageGetter.Contract.GetK(&_IKmanageGetter.CallOpts, _i)
}

// GetK is a free data retrieval call binding the contract method 0xdc0e7f45.
//
// Solidity: function getK(uint64 _i) view returns(uint64)
func (_IKmanageGetter *IKmanageGetterCallerSession) GetK(_i uint64) (uint64, error) {
	return _IKmanageGetter.Contract.GetK(&_IKmanageGetter.CallOpts, _i)
}

// GetKCnt is a free data retrieval call binding the contract method 0x39f2db96.
//
// Solidity: function getKCnt() view returns(uint8)
func (_IKmanageGetter *IKmanageGetterCaller) GetKCnt(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _IKmanageGetter.contract.Call(opts, &out, "getKCnt")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// GetKCnt is a free data retrieval call binding the contract method 0x39f2db96.
//
// Solidity: function getKCnt() view returns(uint8)
func (_IKmanageGetter *IKmanageGetterSession) GetKCnt() (uint8, error) {
	return _IKmanageGetter.Contract.GetKCnt(&_IKmanageGetter.CallOpts)
}

// GetKCnt is a free data retrieval call binding the contract method 0x39f2db96.
//
// Solidity: function getKCnt() view returns(uint8)
func (_IKmanageGetter *IKmanageGetterCallerSession) GetKCnt() (uint8, error) {
	return _IKmanageGetter.Contract.GetKCnt(&_IKmanageGetter.CallOpts)
}

// GetPf is a free data retrieval call binding the contract method 0x4f3c2eab.
//
// Solidity: function getPf(uint8 _ti) view returns(uint64, uint256)
func (_IKmanageGetter *IKmanageGetterCaller) GetPf(opts *bind.CallOpts, _ti uint8) (uint64, *big.Int, error) {
	var out []interface{}
	err := _IKmanageGetter.contract.Call(opts, &out, "getPf", _ti)

	if err != nil {
		return *new(uint64), *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)
	out1 := *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)

	return out0, out1, err

}

// GetPf is a free data retrieval call binding the contract method 0x4f3c2eab.
//
// Solidity: function getPf(uint8 _ti) view returns(uint64, uint256)
func (_IKmanageGetter *IKmanageGetterSession) GetPf(_ti uint8) (uint64, *big.Int, error) {
	return _IKmanageGetter.Contract.GetPf(&_IKmanageGetter.CallOpts, _ti)
}

// GetPf is a free data retrieval call binding the contract method 0x4f3c2eab.
//
// Solidity: function getPf(uint8 _ti) view returns(uint64, uint256)
func (_IKmanageGetter *IKmanageGetterCallerSession) GetPf(_ti uint8) (uint64, *big.Int, error) {
	return _IKmanageGetter.Contract.GetPf(&_IKmanageGetter.CallOpts, _ti)
}

// ManageRate is a free data retrieval call binding the contract method 0x6d23f6c8.
//
// Solidity: function manageRate() view returns(uint8)
func (_IKmanageGetter *IKmanageGetterCaller) ManageRate(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _IKmanageGetter.contract.Call(opts, &out, "manageRate")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ManageRate is a free data retrieval call binding the contract method 0x6d23f6c8.
//
// Solidity: function manageRate() view returns(uint8)
func (_IKmanageGetter *IKmanageGetterSession) ManageRate() (uint8, error) {
	return _IKmanageGetter.Contract.ManageRate(&_IKmanageGetter.CallOpts)
}

// ManageRate is a free data retrieval call binding the contract method 0x6d23f6c8.
//
// Solidity: function manageRate() view returns(uint8)
func (_IKmanageGetter *IKmanageGetterCallerSession) ManageRate() (uint8, error) {
	return _IKmanageGetter.Contract.ManageRate(&_IKmanageGetter.CallOpts)
}

// IKmanageSetterABI is the input ABI used to generate the binding from.
const IKmanageSetterABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"ki\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"cnt\",\"type\":\"uint64\"}],\"name\":\"AddCnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"ti\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"AddProfit\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_ki\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_cnt\",\"type\":\"uint64\"}],\"name\":\"addCnt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_ki\",\"type\":\"uint64\"}],\"name\":\"addKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_money\",\"type\":\"uint256\"}],\"name\":\"addProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_ki\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IKmanageSetterFuncSigs maps the 4-byte function signature to its string representation.
var IKmanageSetterFuncSigs = map[string]string{
	"024130e4": "addCnt(uint64,uint64)",
	"50cbb46f": "addKeeper(uint64)",
	"55d3d7ef": "addProfit(uint8,uint256)",
	"259c6d5e": "withdraw(uint64,uint8,uint256)",
}

// IKmanageSetter is an auto generated Go binding around an Ethereum contract.
type IKmanageSetter struct {
	IKmanageSetterCaller     // Read-only binding to the contract
	IKmanageSetterTransactor // Write-only binding to the contract
	IKmanageSetterFilterer   // Log filterer for contract events
}

// IKmanageSetterCaller is an auto generated read-only Go binding around an Ethereum contract.
type IKmanageSetterCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IKmanageSetterTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IKmanageSetterTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IKmanageSetterFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IKmanageSetterFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IKmanageSetterSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IKmanageSetterSession struct {
	Contract     *IKmanageSetter   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IKmanageSetterCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IKmanageSetterCallerSession struct {
	Contract *IKmanageSetterCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IKmanageSetterTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IKmanageSetterTransactorSession struct {
	Contract     *IKmanageSetterTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IKmanageSetterRaw is an auto generated low-level Go binding around an Ethereum contract.
type IKmanageSetterRaw struct {
	Contract *IKmanageSetter // Generic contract binding to access the raw methods on
}

// IKmanageSetterCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IKmanageSetterCallerRaw struct {
	Contract *IKmanageSetterCaller // Generic read-only contract binding to access the raw methods on
}

// IKmanageSetterTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IKmanageSetterTransactorRaw struct {
	Contract *IKmanageSetterTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIKmanageSetter creates a new instance of IKmanageSetter, bound to a specific deployed contract.
func NewIKmanageSetter(address common.Address, backend bind.ContractBackend) (*IKmanageSetter, error) {
	contract, err := bindIKmanageSetter(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IKmanageSetter{IKmanageSetterCaller: IKmanageSetterCaller{contract: contract}, IKmanageSetterTransactor: IKmanageSetterTransactor{contract: contract}, IKmanageSetterFilterer: IKmanageSetterFilterer{contract: contract}}, nil
}

// NewIKmanageSetterCaller creates a new read-only instance of IKmanageSetter, bound to a specific deployed contract.
func NewIKmanageSetterCaller(address common.Address, caller bind.ContractCaller) (*IKmanageSetterCaller, error) {
	contract, err := bindIKmanageSetter(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IKmanageSetterCaller{contract: contract}, nil
}

// NewIKmanageSetterTransactor creates a new write-only instance of IKmanageSetter, bound to a specific deployed contract.
func NewIKmanageSetterTransactor(address common.Address, transactor bind.ContractTransactor) (*IKmanageSetterTransactor, error) {
	contract, err := bindIKmanageSetter(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IKmanageSetterTransactor{contract: contract}, nil
}

// NewIKmanageSetterFilterer creates a new log filterer instance of IKmanageSetter, bound to a specific deployed contract.
func NewIKmanageSetterFilterer(address common.Address, filterer bind.ContractFilterer) (*IKmanageSetterFilterer, error) {
	contract, err := bindIKmanageSetter(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IKmanageSetterFilterer{contract: contract}, nil
}

// bindIKmanageSetter binds a generic wrapper to an already deployed contract.
func bindIKmanageSetter(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IKmanageSetterABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IKmanageSetter *IKmanageSetterRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IKmanageSetter.Contract.IKmanageSetterCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IKmanageSetter *IKmanageSetterRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IKmanageSetter.Contract.IKmanageSetterTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IKmanageSetter *IKmanageSetterRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IKmanageSetter.Contract.IKmanageSetterTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IKmanageSetter *IKmanageSetterCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IKmanageSetter.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IKmanageSetter *IKmanageSetterTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IKmanageSetter.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IKmanageSetter *IKmanageSetterTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IKmanageSetter.Contract.contract.Transact(opts, method, params...)
}

// AddCnt is a paid mutator transaction binding the contract method 0x024130e4.
//
// Solidity: function addCnt(uint64 _ki, uint64 _cnt) returns()
func (_IKmanageSetter *IKmanageSetterTransactor) AddCnt(opts *bind.TransactOpts, _ki uint64, _cnt uint64) (*types.Transaction, error) {
	return _IKmanageSetter.contract.Transact(opts, "addCnt", _ki, _cnt)
}

// AddCnt is a paid mutator transaction binding the contract method 0x024130e4.
//
// Solidity: function addCnt(uint64 _ki, uint64 _cnt) returns()
func (_IKmanageSetter *IKmanageSetterSession) AddCnt(_ki uint64, _cnt uint64) (*types.Transaction, error) {
	return _IKmanageSetter.Contract.AddCnt(&_IKmanageSetter.TransactOpts, _ki, _cnt)
}

// AddCnt is a paid mutator transaction binding the contract method 0x024130e4.
//
// Solidity: function addCnt(uint64 _ki, uint64 _cnt) returns()
func (_IKmanageSetter *IKmanageSetterTransactorSession) AddCnt(_ki uint64, _cnt uint64) (*types.Transaction, error) {
	return _IKmanageSetter.Contract.AddCnt(&_IKmanageSetter.TransactOpts, _ki, _cnt)
}

// AddKeeper is a paid mutator transaction binding the contract method 0x50cbb46f.
//
// Solidity: function addKeeper(uint64 _ki) returns()
func (_IKmanageSetter *IKmanageSetterTransactor) AddKeeper(opts *bind.TransactOpts, _ki uint64) (*types.Transaction, error) {
	return _IKmanageSetter.contract.Transact(opts, "addKeeper", _ki)
}

// AddKeeper is a paid mutator transaction binding the contract method 0x50cbb46f.
//
// Solidity: function addKeeper(uint64 _ki) returns()
func (_IKmanageSetter *IKmanageSetterSession) AddKeeper(_ki uint64) (*types.Transaction, error) {
	return _IKmanageSetter.Contract.AddKeeper(&_IKmanageSetter.TransactOpts, _ki)
}

// AddKeeper is a paid mutator transaction binding the contract method 0x50cbb46f.
//
// Solidity: function addKeeper(uint64 _ki) returns()
func (_IKmanageSetter *IKmanageSetterTransactorSession) AddKeeper(_ki uint64) (*types.Transaction, error) {
	return _IKmanageSetter.Contract.AddKeeper(&_IKmanageSetter.TransactOpts, _ki)
}

// AddProfit is a paid mutator transaction binding the contract method 0x55d3d7ef.
//
// Solidity: function addProfit(uint8 _ti, uint256 _money) returns()
func (_IKmanageSetter *IKmanageSetterTransactor) AddProfit(opts *bind.TransactOpts, _ti uint8, _money *big.Int) (*types.Transaction, error) {
	return _IKmanageSetter.contract.Transact(opts, "addProfit", _ti, _money)
}

// AddProfit is a paid mutator transaction binding the contract method 0x55d3d7ef.
//
// Solidity: function addProfit(uint8 _ti, uint256 _money) returns()
func (_IKmanageSetter *IKmanageSetterSession) AddProfit(_ti uint8, _money *big.Int) (*types.Transaction, error) {
	return _IKmanageSetter.Contract.AddProfit(&_IKmanageSetter.TransactOpts, _ti, _money)
}

// AddProfit is a paid mutator transaction binding the contract method 0x55d3d7ef.
//
// Solidity: function addProfit(uint8 _ti, uint256 _money) returns()
func (_IKmanageSetter *IKmanageSetterTransactorSession) AddProfit(_ti uint8, _money *big.Int) (*types.Transaction, error) {
	return _IKmanageSetter.Contract.AddProfit(&_IKmanageSetter.TransactOpts, _ti, _money)
}

// Withdraw is a paid mutator transaction binding the contract method 0x259c6d5e.
//
// Solidity: function withdraw(uint64 _ki, uint8 _ti, uint256 money) returns(uint256)
func (_IKmanageSetter *IKmanageSetterTransactor) Withdraw(opts *bind.TransactOpts, _ki uint64, _ti uint8, money *big.Int) (*types.Transaction, error) {
	return _IKmanageSetter.contract.Transact(opts, "withdraw", _ki, _ti, money)
}

// Withdraw is a paid mutator transaction binding the contract method 0x259c6d5e.
//
// Solidity: function withdraw(uint64 _ki, uint8 _ti, uint256 money) returns(uint256)
func (_IKmanageSetter *IKmanageSetterSession) Withdraw(_ki uint64, _ti uint8, money *big.Int) (*types.Transaction, error) {
	return _IKmanageSetter.Contract.Withdraw(&_IKmanageSetter.TransactOpts, _ki, _ti, money)
}

// Withdraw is a paid mutator transaction binding the contract method 0x259c6d5e.
//
// Solidity: function withdraw(uint64 _ki, uint8 _ti, uint256 money) returns(uint256)
func (_IKmanageSetter *IKmanageSetterTransactorSession) Withdraw(_ki uint64, _ti uint8, money *big.Int) (*types.Transaction, error) {
	return _IKmanageSetter.Contract.Withdraw(&_IKmanageSetter.TransactOpts, _ki, _ti, money)
}

// IKmanageSetterAddCntIterator is returned from FilterAddCnt and is used to iterate over the raw logs and unpacked data for AddCnt events raised by the IKmanageSetter contract.
type IKmanageSetterAddCntIterator struct {
	Event *IKmanageSetterAddCnt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IKmanageSetterAddCntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IKmanageSetterAddCnt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IKmanageSetterAddCnt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IKmanageSetterAddCntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IKmanageSetterAddCntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IKmanageSetterAddCnt represents a AddCnt event raised by the IKmanageSetter contract.
type IKmanageSetterAddCnt struct {
	Ki  uint64
	Cnt uint64
	Raw types.Log // Blockchain specific contextual infos
}

// FilterAddCnt is a free log retrieval operation binding the contract event 0x5372d6aad551334f508508499c71755ebc6cde46b83fc1f944f1f0ae33cbb4c4.
//
// Solidity: event AddCnt(uint64 indexed ki, uint64 cnt)
func (_IKmanageSetter *IKmanageSetterFilterer) FilterAddCnt(opts *bind.FilterOpts, ki []uint64) (*IKmanageSetterAddCntIterator, error) {

	var kiRule []interface{}
	for _, kiItem := range ki {
		kiRule = append(kiRule, kiItem)
	}

	logs, sub, err := _IKmanageSetter.contract.FilterLogs(opts, "AddCnt", kiRule)
	if err != nil {
		return nil, err
	}
	return &IKmanageSetterAddCntIterator{contract: _IKmanageSetter.contract, event: "AddCnt", logs: logs, sub: sub}, nil
}

// WatchAddCnt is a free log subscription operation binding the contract event 0x5372d6aad551334f508508499c71755ebc6cde46b83fc1f944f1f0ae33cbb4c4.
//
// Solidity: event AddCnt(uint64 indexed ki, uint64 cnt)
func (_IKmanageSetter *IKmanageSetterFilterer) WatchAddCnt(opts *bind.WatchOpts, sink chan<- *IKmanageSetterAddCnt, ki []uint64) (event.Subscription, error) {

	var kiRule []interface{}
	for _, kiItem := range ki {
		kiRule = append(kiRule, kiItem)
	}

	logs, sub, err := _IKmanageSetter.contract.WatchLogs(opts, "AddCnt", kiRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IKmanageSetterAddCnt)
				if err := _IKmanageSetter.contract.UnpackLog(event, "AddCnt", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddCnt is a log parse operation binding the contract event 0x5372d6aad551334f508508499c71755ebc6cde46b83fc1f944f1f0ae33cbb4c4.
//
// Solidity: event AddCnt(uint64 indexed ki, uint64 cnt)
func (_IKmanageSetter *IKmanageSetterFilterer) ParseAddCnt(log types.Log) (*IKmanageSetterAddCnt, error) {
	event := new(IKmanageSetterAddCnt)
	if err := _IKmanageSetter.contract.UnpackLog(event, "AddCnt", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IKmanageSetterAddProfitIterator is returned from FilterAddProfit and is used to iterate over the raw logs and unpacked data for AddProfit events raised by the IKmanageSetter contract.
type IKmanageSetterAddProfitIterator struct {
	Event *IKmanageSetterAddProfit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IKmanageSetterAddProfitIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IKmanageSetterAddProfit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IKmanageSetterAddProfit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IKmanageSetterAddProfitIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IKmanageSetterAddProfitIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IKmanageSetterAddProfit represents a AddProfit event raised by the IKmanageSetter contract.
type IKmanageSetterAddProfit struct {
	Ti    uint8
	Money *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterAddProfit is a free log retrieval operation binding the contract event 0xe5fd8ec20bdfeb1fadd32ec3786545a1db18d74f952effda5c6cd50af7c2e9e8.
//
// Solidity: event AddProfit(uint8 indexed ti, uint256 money)
func (_IKmanageSetter *IKmanageSetterFilterer) FilterAddProfit(opts *bind.FilterOpts, ti []uint8) (*IKmanageSetterAddProfitIterator, error) {

	var tiRule []interface{}
	for _, tiItem := range ti {
		tiRule = append(tiRule, tiItem)
	}

	logs, sub, err := _IKmanageSetter.contract.FilterLogs(opts, "AddProfit", tiRule)
	if err != nil {
		return nil, err
	}
	return &IKmanageSetterAddProfitIterator{contract: _IKmanageSetter.contract, event: "AddProfit", logs: logs, sub: sub}, nil
}

// WatchAddProfit is a free log subscription operation binding the contract event 0xe5fd8ec20bdfeb1fadd32ec3786545a1db18d74f952effda5c6cd50af7c2e9e8.
//
// Solidity: event AddProfit(uint8 indexed ti, uint256 money)
func (_IKmanageSetter *IKmanageSetterFilterer) WatchAddProfit(opts *bind.WatchOpts, sink chan<- *IKmanageSetterAddProfit, ti []uint8) (event.Subscription, error) {

	var tiRule []interface{}
	for _, tiItem := range ti {
		tiRule = append(tiRule, tiItem)
	}

	logs, sub, err := _IKmanageSetter.contract.WatchLogs(opts, "AddProfit", tiRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IKmanageSetterAddProfit)
				if err := _IKmanageSetter.contract.UnpackLog(event, "AddProfit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddProfit is a log parse operation binding the contract event 0xe5fd8ec20bdfeb1fadd32ec3786545a1db18d74f952effda5c6cd50af7c2e9e8.
//
// Solidity: event AddProfit(uint8 indexed ti, uint256 money)
func (_IKmanageSetter *IKmanageSetterFilterer) ParseAddProfit(log types.Log) (*IKmanageSetterAddProfit, error) {
	event := new(IKmanageSetterAddProfit)
	if err := _IKmanageSetter.contract.UnpackLog(event, "AddProfit", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IOwnerABI is the input ABI used to generate the binding from.
const IOwnerABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"name\":\"AddOwner\",\"type\":\"event\"}]"

// IOwner is an auto generated Go binding around an Ethereum contract.
type IOwner struct {
	IOwnerCaller     // Read-only binding to the contract
	IOwnerTransactor // Write-only binding to the contract
	IOwnerFilterer   // Log filterer for contract events
}

// IOwnerCaller is an auto generated read-only Go binding around an Ethereum contract.
type IOwnerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IOwnerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IOwnerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IOwnerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IOwnerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IOwnerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IOwnerSession struct {
	Contract     *IOwner           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IOwnerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IOwnerCallerSession struct {
	Contract *IOwnerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IOwnerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IOwnerTransactorSession struct {
	Contract     *IOwnerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IOwnerRaw is an auto generated low-level Go binding around an Ethereum contract.
type IOwnerRaw struct {
	Contract *IOwner // Generic contract binding to access the raw methods on
}

// IOwnerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IOwnerCallerRaw struct {
	Contract *IOwnerCaller // Generic read-only contract binding to access the raw methods on
}

// IOwnerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IOwnerTransactorRaw struct {
	Contract *IOwnerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIOwner creates a new instance of IOwner, bound to a specific deployed contract.
func NewIOwner(address common.Address, backend bind.ContractBackend) (*IOwner, error) {
	contract, err := bindIOwner(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IOwner{IOwnerCaller: IOwnerCaller{contract: contract}, IOwnerTransactor: IOwnerTransactor{contract: contract}, IOwnerFilterer: IOwnerFilterer{contract: contract}}, nil
}

// NewIOwnerCaller creates a new read-only instance of IOwner, bound to a specific deployed contract.
func NewIOwnerCaller(address common.Address, caller bind.ContractCaller) (*IOwnerCaller, error) {
	contract, err := bindIOwner(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IOwnerCaller{contract: contract}, nil
}

// NewIOwnerTransactor creates a new write-only instance of IOwner, bound to a specific deployed contract.
func NewIOwnerTransactor(address common.Address, transactor bind.ContractTransactor) (*IOwnerTransactor, error) {
	contract, err := bindIOwner(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IOwnerTransactor{contract: contract}, nil
}

// NewIOwnerFilterer creates a new log filterer instance of IOwner, bound to a specific deployed contract.
func NewIOwnerFilterer(address common.Address, filterer bind.ContractFilterer) (*IOwnerFilterer, error) {
	contract, err := bindIOwner(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IOwnerFilterer{contract: contract}, nil
}

// bindIOwner binds a generic wrapper to an already deployed contract.
func bindIOwner(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IOwnerABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IOwner *IOwnerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IOwner.Contract.IOwnerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IOwner *IOwnerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IOwner.Contract.IOwnerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IOwner *IOwnerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IOwner.Contract.IOwnerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IOwner *IOwnerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IOwner.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IOwner *IOwnerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IOwner.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IOwner *IOwnerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IOwner.Contract.contract.Transact(opts, method, params...)
}

// IOwnerAddOwnerIterator is returned from FilterAddOwner and is used to iterate over the raw logs and unpacked data for AddOwner events raised by the IOwner contract.
type IOwnerAddOwnerIterator struct {
	Event *IOwnerAddOwner // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IOwnerAddOwnerIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IOwnerAddOwner)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IOwnerAddOwner)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IOwnerAddOwnerIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IOwnerAddOwnerIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IOwnerAddOwner represents a AddOwner event raised by the IOwner contract.
type IOwnerAddOwner struct {
	From  common.Address
	IsSet bool
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterAddOwner is a free log retrieval operation binding the contract event 0x938b2a24c98e4e542127ffa74a91e48942c2bddccae3b6d75f82bfda7bbc0807.
//
// Solidity: event AddOwner(address from, bool isSet)
func (_IOwner *IOwnerFilterer) FilterAddOwner(opts *bind.FilterOpts) (*IOwnerAddOwnerIterator, error) {

	logs, sub, err := _IOwner.contract.FilterLogs(opts, "AddOwner")
	if err != nil {
		return nil, err
	}
	return &IOwnerAddOwnerIterator{contract: _IOwner.contract, event: "AddOwner", logs: logs, sub: sub}, nil
}

// WatchAddOwner is a free log subscription operation binding the contract event 0x938b2a24c98e4e542127ffa74a91e48942c2bddccae3b6d75f82bfda7bbc0807.
//
// Solidity: event AddOwner(address from, bool isSet)
func (_IOwner *IOwnerFilterer) WatchAddOwner(opts *bind.WatchOpts, sink chan<- *IOwnerAddOwner) (event.Subscription, error) {

	logs, sub, err := _IOwner.contract.WatchLogs(opts, "AddOwner")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IOwnerAddOwner)
				if err := _IOwner.contract.UnpackLog(event, "AddOwner", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddOwner is a log parse operation binding the contract event 0x938b2a24c98e4e542127ffa74a91e48942c2bddccae3b6d75f82bfda7bbc0807.
//
// Solidity: event AddOwner(address from, bool isSet)
func (_IOwner *IOwnerFilterer) ParseAddOwner(log types.Log) (*IOwnerAddOwner, error) {
	event := new(IOwnerAddOwner)
	if err := _IOwner.contract.UnpackLog(event, "AddOwner", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolABI is the input ABI used to generate the binding from.
const IPoolABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"Inflow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"Outflow\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"inflow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"outflow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]"

// IPoolFuncSigs maps the 4-byte function signature to its string representation.
var IPoolFuncSigs = map[string]string{
	"368007fe": "inflow(address,address,uint256)",
	"530345bb": "outflow(address,address,uint256)",
}

// IPool is an auto generated Go binding around an Ethereum contract.
type IPool struct {
	IPoolCaller     // Read-only binding to the contract
	IPoolTransactor // Write-only binding to the contract
	IPoolFilterer   // Log filterer for contract events
}

// IPoolCaller is an auto generated read-only Go binding around an Ethereum contract.
type IPoolCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPoolTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IPoolTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPoolFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IPoolFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPoolSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IPoolSession struct {
	Contract     *IPool            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IPoolCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IPoolCallerSession struct {
	Contract *IPoolCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IPoolTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IPoolTransactorSession struct {
	Contract     *IPoolTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IPoolRaw is an auto generated low-level Go binding around an Ethereum contract.
type IPoolRaw struct {
	Contract *IPool // Generic contract binding to access the raw methods on
}

// IPoolCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IPoolCallerRaw struct {
	Contract *IPoolCaller // Generic read-only contract binding to access the raw methods on
}

// IPoolTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IPoolTransactorRaw struct {
	Contract *IPoolTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIPool creates a new instance of IPool, bound to a specific deployed contract.
func NewIPool(address common.Address, backend bind.ContractBackend) (*IPool, error) {
	contract, err := bindIPool(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IPool{IPoolCaller: IPoolCaller{contract: contract}, IPoolTransactor: IPoolTransactor{contract: contract}, IPoolFilterer: IPoolFilterer{contract: contract}}, nil
}

// NewIPoolCaller creates a new read-only instance of IPool, bound to a specific deployed contract.
func NewIPoolCaller(address common.Address, caller bind.ContractCaller) (*IPoolCaller, error) {
	contract, err := bindIPool(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IPoolCaller{contract: contract}, nil
}

// NewIPoolTransactor creates a new write-only instance of IPool, bound to a specific deployed contract.
func NewIPoolTransactor(address common.Address, transactor bind.ContractTransactor) (*IPoolTransactor, error) {
	contract, err := bindIPool(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IPoolTransactor{contract: contract}, nil
}

// NewIPoolFilterer creates a new log filterer instance of IPool, bound to a specific deployed contract.
func NewIPoolFilterer(address common.Address, filterer bind.ContractFilterer) (*IPoolFilterer, error) {
	contract, err := bindIPool(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IPoolFilterer{contract: contract}, nil
}

// bindIPool binds a generic wrapper to an already deployed contract.
func bindIPool(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IPoolABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IPool *IPoolRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IPool.Contract.IPoolCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IPool *IPoolRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IPool.Contract.IPoolTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IPool *IPoolRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IPool.Contract.IPoolTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IPool *IPoolCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IPool.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IPool *IPoolTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IPool.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IPool *IPoolTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IPool.Contract.contract.Transact(opts, method, params...)
}

// Inflow is a paid mutator transaction binding the contract method 0x368007fe.
//
// Solidity: function inflow(address tAddr, address from, uint256 money) payable returns()
func (_IPool *IPoolTransactor) Inflow(opts *bind.TransactOpts, tAddr common.Address, from common.Address, money *big.Int) (*types.Transaction, error) {
	return _IPool.contract.Transact(opts, "inflow", tAddr, from, money)
}

// Inflow is a paid mutator transaction binding the contract method 0x368007fe.
//
// Solidity: function inflow(address tAddr, address from, uint256 money) payable returns()
func (_IPool *IPoolSession) Inflow(tAddr common.Address, from common.Address, money *big.Int) (*types.Transaction, error) {
	return _IPool.Contract.Inflow(&_IPool.TransactOpts, tAddr, from, money)
}

// Inflow is a paid mutator transaction binding the contract method 0x368007fe.
//
// Solidity: function inflow(address tAddr, address from, uint256 money) payable returns()
func (_IPool *IPoolTransactorSession) Inflow(tAddr common.Address, from common.Address, money *big.Int) (*types.Transaction, error) {
	return _IPool.Contract.Inflow(&_IPool.TransactOpts, tAddr, from, money)
}

// Outflow is a paid mutator transaction binding the contract method 0x530345bb.
//
// Solidity: function outflow(address tAddr, address to, uint256 money) payable returns()
func (_IPool *IPoolTransactor) Outflow(opts *bind.TransactOpts, tAddr common.Address, to common.Address, money *big.Int) (*types.Transaction, error) {
	return _IPool.contract.Transact(opts, "outflow", tAddr, to, money)
}

// Outflow is a paid mutator transaction binding the contract method 0x530345bb.
//
// Solidity: function outflow(address tAddr, address to, uint256 money) payable returns()
func (_IPool *IPoolSession) Outflow(tAddr common.Address, to common.Address, money *big.Int) (*types.Transaction, error) {
	return _IPool.Contract.Outflow(&_IPool.TransactOpts, tAddr, to, money)
}

// Outflow is a paid mutator transaction binding the contract method 0x530345bb.
//
// Solidity: function outflow(address tAddr, address to, uint256 money) payable returns()
func (_IPool *IPoolTransactorSession) Outflow(tAddr common.Address, to common.Address, money *big.Int) (*types.Transaction, error) {
	return _IPool.Contract.Outflow(&_IPool.TransactOpts, tAddr, to, money)
}

// IPoolInflowIterator is returned from FilterInflow and is used to iterate over the raw logs and unpacked data for Inflow events raised by the IPool contract.
type IPoolInflowIterator struct {
	Event *IPoolInflow // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolInflowIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolInflow)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolInflow)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolInflowIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolInflowIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolInflow represents a Inflow event raised by the IPool contract.
type IPoolInflow struct {
	From  common.Address
	TAddr common.Address
	Money *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterInflow is a free log retrieval operation binding the contract event 0xde52ea03a3979fafeaf8ea9d7fe6b3ddc6a95e9e8c0922562db3a047c0d72578.
//
// Solidity: event Inflow(address indexed from, address tAddr, uint256 money)
func (_IPool *IPoolFilterer) FilterInflow(opts *bind.FilterOpts, from []common.Address) (*IPoolInflowIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IPool.contract.FilterLogs(opts, "Inflow", fromRule)
	if err != nil {
		return nil, err
	}
	return &IPoolInflowIterator{contract: _IPool.contract, event: "Inflow", logs: logs, sub: sub}, nil
}

// WatchInflow is a free log subscription operation binding the contract event 0xde52ea03a3979fafeaf8ea9d7fe6b3ddc6a95e9e8c0922562db3a047c0d72578.
//
// Solidity: event Inflow(address indexed from, address tAddr, uint256 money)
func (_IPool *IPoolFilterer) WatchInflow(opts *bind.WatchOpts, sink chan<- *IPoolInflow, from []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IPool.contract.WatchLogs(opts, "Inflow", fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolInflow)
				if err := _IPool.contract.UnpackLog(event, "Inflow", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInflow is a log parse operation binding the contract event 0xde52ea03a3979fafeaf8ea9d7fe6b3ddc6a95e9e8c0922562db3a047c0d72578.
//
// Solidity: event Inflow(address indexed from, address tAddr, uint256 money)
func (_IPool *IPoolFilterer) ParseInflow(log types.Log) (*IPoolInflow, error) {
	event := new(IPoolInflow)
	if err := _IPool.contract.UnpackLog(event, "Inflow", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolOutflowIterator is returned from FilterOutflow and is used to iterate over the raw logs and unpacked data for Outflow events raised by the IPool contract.
type IPoolOutflowIterator struct {
	Event *IPoolOutflow // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolOutflowIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolOutflow)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolOutflow)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolOutflowIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolOutflowIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolOutflow represents a Outflow event raised by the IPool contract.
type IPoolOutflow struct {
	To    common.Address
	TAddr common.Address
	Money *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterOutflow is a free log retrieval operation binding the contract event 0x4eb2adb2eba0bb5546cc2e8d62ae0c32e7b6fb40567d53be433eb4b17f5f996e.
//
// Solidity: event Outflow(address indexed to, address tAddr, uint256 money)
func (_IPool *IPoolFilterer) FilterOutflow(opts *bind.FilterOpts, to []common.Address) (*IPoolOutflowIterator, error) {

	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IPool.contract.FilterLogs(opts, "Outflow", toRule)
	if err != nil {
		return nil, err
	}
	return &IPoolOutflowIterator{contract: _IPool.contract, event: "Outflow", logs: logs, sub: sub}, nil
}

// WatchOutflow is a free log subscription operation binding the contract event 0x4eb2adb2eba0bb5546cc2e8d62ae0c32e7b6fb40567d53be433eb4b17f5f996e.
//
// Solidity: event Outflow(address indexed to, address tAddr, uint256 money)
func (_IPool *IPoolFilterer) WatchOutflow(opts *bind.WatchOpts, sink chan<- *IPoolOutflow, to []common.Address) (event.Subscription, error) {

	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IPool.contract.WatchLogs(opts, "Outflow", toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolOutflow)
				if err := _IPool.contract.UnpackLog(event, "Outflow", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOutflow is a log parse operation binding the contract event 0x4eb2adb2eba0bb5546cc2e8d62ae0c32e7b6fb40567d53be433eb4b17f5f996e.
//
// Solidity: event Outflow(address indexed to, address tAddr, uint256 money)
func (_IPool *IPoolFilterer) ParseOutflow(log types.Log) (*IPoolOutflow, error) {
	event := new(IPoolOutflow)
	if err := _IPool.contract.UnpackLog(event, "Outflow", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IRoleGetterABI is the input ABI used to generate the binding from.
const IRoleGetterABI = "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_i\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"_rType\",\"type\":\"uint8\"}],\"name\":\"checkIG\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getACnt\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"getAcc\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_i\",\"type\":\"uint64\"}],\"name\":\"getAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"getRInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isBan\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"rType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"index\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"gIndex\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"next\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"}],\"internalType\":\"structRoleOut\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// IRoleGetterFuncSigs maps the 4-byte function signature to its string representation.
var IRoleGetterFuncSigs = map[string]string{
	"7738515f": "checkIG(uint64,uint8)",
	"7264a551": "getACnt()",
	"caca4a06": "getAcc(address)",
	"9332aa6e": "getAddr(uint64)",
	"441abace": "getRInfo(address)",
}

// IRoleGetter is an auto generated Go binding around an Ethereum contract.
type IRoleGetter struct {
	IRoleGetterCaller     // Read-only binding to the contract
	IRoleGetterTransactor // Write-only binding to the contract
	IRoleGetterFilterer   // Log filterer for contract events
}

// IRoleGetterCaller is an auto generated read-only Go binding around an Ethereum contract.
type IRoleGetterCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IRoleGetterTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IRoleGetterTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IRoleGetterFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IRoleGetterFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IRoleGetterSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IRoleGetterSession struct {
	Contract     *IRoleGetter      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IRoleGetterCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IRoleGetterCallerSession struct {
	Contract *IRoleGetterCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// IRoleGetterTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IRoleGetterTransactorSession struct {
	Contract     *IRoleGetterTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// IRoleGetterRaw is an auto generated low-level Go binding around an Ethereum contract.
type IRoleGetterRaw struct {
	Contract *IRoleGetter // Generic contract binding to access the raw methods on
}

// IRoleGetterCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IRoleGetterCallerRaw struct {
	Contract *IRoleGetterCaller // Generic read-only contract binding to access the raw methods on
}

// IRoleGetterTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IRoleGetterTransactorRaw struct {
	Contract *IRoleGetterTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIRoleGetter creates a new instance of IRoleGetter, bound to a specific deployed contract.
func NewIRoleGetter(address common.Address, backend bind.ContractBackend) (*IRoleGetter, error) {
	contract, err := bindIRoleGetter(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IRoleGetter{IRoleGetterCaller: IRoleGetterCaller{contract: contract}, IRoleGetterTransactor: IRoleGetterTransactor{contract: contract}, IRoleGetterFilterer: IRoleGetterFilterer{contract: contract}}, nil
}

// NewIRoleGetterCaller creates a new read-only instance of IRoleGetter, bound to a specific deployed contract.
func NewIRoleGetterCaller(address common.Address, caller bind.ContractCaller) (*IRoleGetterCaller, error) {
	contract, err := bindIRoleGetter(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IRoleGetterCaller{contract: contract}, nil
}

// NewIRoleGetterTransactor creates a new write-only instance of IRoleGetter, bound to a specific deployed contract.
func NewIRoleGetterTransactor(address common.Address, transactor bind.ContractTransactor) (*IRoleGetterTransactor, error) {
	contract, err := bindIRoleGetter(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IRoleGetterTransactor{contract: contract}, nil
}

// NewIRoleGetterFilterer creates a new log filterer instance of IRoleGetter, bound to a specific deployed contract.
func NewIRoleGetterFilterer(address common.Address, filterer bind.ContractFilterer) (*IRoleGetterFilterer, error) {
	contract, err := bindIRoleGetter(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IRoleGetterFilterer{contract: contract}, nil
}

// bindIRoleGetter binds a generic wrapper to an already deployed contract.
func bindIRoleGetter(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IRoleGetterABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IRoleGetter *IRoleGetterRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IRoleGetter.Contract.IRoleGetterCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IRoleGetter *IRoleGetterRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IRoleGetter.Contract.IRoleGetterTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IRoleGetter *IRoleGetterRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IRoleGetter.Contract.IRoleGetterTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IRoleGetter *IRoleGetterCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IRoleGetter.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IRoleGetter *IRoleGetterTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IRoleGetter.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IRoleGetter *IRoleGetterTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IRoleGetter.Contract.contract.Transact(opts, method, params...)
}

// CheckIG is a free data retrieval call binding the contract method 0x7738515f.
//
// Solidity: function checkIG(uint64 _i, uint8 _rType) view returns(address, address, uint64, uint8)
func (_IRoleGetter *IRoleGetterCaller) CheckIG(opts *bind.CallOpts, _i uint64, _rType uint8) (common.Address, common.Address, uint64, uint8, error) {
	var out []interface{}
	err := _IRoleGetter.contract.Call(opts, &out, "checkIG", _i, _rType)

	if err != nil {
		return *new(common.Address), *new(common.Address), *new(uint64), *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	out1 := *abi.ConvertType(out[1], new(common.Address)).(*common.Address)
	out2 := *abi.ConvertType(out[2], new(uint64)).(*uint64)
	out3 := *abi.ConvertType(out[3], new(uint8)).(*uint8)

	return out0, out1, out2, out3, err

}

// CheckIG is a free data retrieval call binding the contract method 0x7738515f.
//
// Solidity: function checkIG(uint64 _i, uint8 _rType) view returns(address, address, uint64, uint8)
func (_IRoleGetter *IRoleGetterSession) CheckIG(_i uint64, _rType uint8) (common.Address, common.Address, uint64, uint8, error) {
	return _IRoleGetter.Contract.CheckIG(&_IRoleGetter.CallOpts, _i, _rType)
}

// CheckIG is a free data retrieval call binding the contract method 0x7738515f.
//
// Solidity: function checkIG(uint64 _i, uint8 _rType) view returns(address, address, uint64, uint8)
func (_IRoleGetter *IRoleGetterCallerSession) CheckIG(_i uint64, _rType uint8) (common.Address, common.Address, uint64, uint8, error) {
	return _IRoleGetter.Contract.CheckIG(&_IRoleGetter.CallOpts, _i, _rType)
}

// GetACnt is a free data retrieval call binding the contract method 0x7264a551.
//
// Solidity: function getACnt() view returns(uint64)
func (_IRoleGetter *IRoleGetterCaller) GetACnt(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _IRoleGetter.contract.Call(opts, &out, "getACnt")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// GetACnt is a free data retrieval call binding the contract method 0x7264a551.
//
// Solidity: function getACnt() view returns(uint64)
func (_IRoleGetter *IRoleGetterSession) GetACnt() (uint64, error) {
	return _IRoleGetter.Contract.GetACnt(&_IRoleGetter.CallOpts)
}

// GetACnt is a free data retrieval call binding the contract method 0x7264a551.
//
// Solidity: function getACnt() view returns(uint64)
func (_IRoleGetter *IRoleGetterCallerSession) GetACnt() (uint64, error) {
	return _IRoleGetter.Contract.GetACnt(&_IRoleGetter.CallOpts)
}

// GetAcc is a free data retrieval call binding the contract method 0xcaca4a06.
//
// Solidity: function getAcc(address _a) view returns(uint64)
func (_IRoleGetter *IRoleGetterCaller) GetAcc(opts *bind.CallOpts, _a common.Address) (uint64, error) {
	var out []interface{}
	err := _IRoleGetter.contract.Call(opts, &out, "getAcc", _a)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// GetAcc is a free data retrieval call binding the contract method 0xcaca4a06.
//
// Solidity: function getAcc(address _a) view returns(uint64)
func (_IRoleGetter *IRoleGetterSession) GetAcc(_a common.Address) (uint64, error) {
	return _IRoleGetter.Contract.GetAcc(&_IRoleGetter.CallOpts, _a)
}

// GetAcc is a free data retrieval call binding the contract method 0xcaca4a06.
//
// Solidity: function getAcc(address _a) view returns(uint64)
func (_IRoleGetter *IRoleGetterCallerSession) GetAcc(_a common.Address) (uint64, error) {
	return _IRoleGetter.Contract.GetAcc(&_IRoleGetter.CallOpts, _a)
}

// GetAddr is a free data retrieval call binding the contract method 0x9332aa6e.
//
// Solidity: function getAddr(uint64 _i) view returns(address)
func (_IRoleGetter *IRoleGetterCaller) GetAddr(opts *bind.CallOpts, _i uint64) (common.Address, error) {
	var out []interface{}
	err := _IRoleGetter.contract.Call(opts, &out, "getAddr", _i)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetAddr is a free data retrieval call binding the contract method 0x9332aa6e.
//
// Solidity: function getAddr(uint64 _i) view returns(address)
func (_IRoleGetter *IRoleGetterSession) GetAddr(_i uint64) (common.Address, error) {
	return _IRoleGetter.Contract.GetAddr(&_IRoleGetter.CallOpts, _i)
}

// GetAddr is a free data retrieval call binding the contract method 0x9332aa6e.
//
// Solidity: function getAddr(uint64 _i) view returns(address)
func (_IRoleGetter *IRoleGetterCallerSession) GetAddr(_i uint64) (common.Address, error) {
	return _IRoleGetter.Contract.GetAddr(&_IRoleGetter.CallOpts, _i)
}

// GetRInfo is a free data retrieval call binding the contract method 0x441abace.
//
// Solidity: function getRInfo(address _a) view returns((bool,bool,uint8,uint64,uint64,address,address,bytes))
func (_IRoleGetter *IRoleGetterCaller) GetRInfo(opts *bind.CallOpts, _a common.Address) (RoleOut, error) {
	var out []interface{}
	err := _IRoleGetter.contract.Call(opts, &out, "getRInfo", _a)

	if err != nil {
		return *new(RoleOut), err
	}

	out0 := *abi.ConvertType(out[0], new(RoleOut)).(*RoleOut)

	return out0, err

}

// GetRInfo is a free data retrieval call binding the contract method 0x441abace.
//
// Solidity: function getRInfo(address _a) view returns((bool,bool,uint8,uint64,uint64,address,address,bytes))
func (_IRoleGetter *IRoleGetterSession) GetRInfo(_a common.Address) (RoleOut, error) {
	return _IRoleGetter.Contract.GetRInfo(&_IRoleGetter.CallOpts, _a)
}

// GetRInfo is a free data retrieval call binding the contract method 0x441abace.
//
// Solidity: function getRInfo(address _a) view returns((bool,bool,uint8,uint64,uint64,address,address,bytes))
func (_IRoleGetter *IRoleGetterCallerSession) GetRInfo(_a common.Address) (RoleOut, error) {
	return _IRoleGetter.Contract.GetRInfo(&_IRoleGetter.CallOpts, _a)
}

// ITokenGetterABI is the input ABI used to generate the binding from.
const ITokenGetterABI = "[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"}],\"name\":\"checkT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_ti\",\"type\":\"uint8\"}],\"name\":\"getTA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTCnt\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_t\",\"type\":\"address\"}],\"name\":\"getTI\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ITokenGetterFuncSigs maps the 4-byte function signature to its string representation.
var ITokenGetterFuncSigs = map[string]string{
	"81abb8fe": "checkT(uint8)",
	"8bb4a637": "getTA(uint8)",
	"7600b86a": "getTCnt()",
	"2df2685f": "getTI(address)",
}

// ITokenGetter is an auto generated Go binding around an Ethereum contract.
type ITokenGetter struct {
	ITokenGetterCaller     // Read-only binding to the contract
	ITokenGetterTransactor // Write-only binding to the contract
	ITokenGetterFilterer   // Log filterer for contract events
}

// ITokenGetterCaller is an auto generated read-only Go binding around an Ethereum contract.
type ITokenGetterCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ITokenGetterTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ITokenGetterTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ITokenGetterFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ITokenGetterFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ITokenGetterSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ITokenGetterSession struct {
	Contract     *ITokenGetter     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ITokenGetterCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ITokenGetterCallerSession struct {
	Contract *ITokenGetterCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// ITokenGetterTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ITokenGetterTransactorSession struct {
	Contract     *ITokenGetterTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// ITokenGetterRaw is an auto generated low-level Go binding around an Ethereum contract.
type ITokenGetterRaw struct {
	Contract *ITokenGetter // Generic contract binding to access the raw methods on
}

// ITokenGetterCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ITokenGetterCallerRaw struct {
	Contract *ITokenGetterCaller // Generic read-only contract binding to access the raw methods on
}

// ITokenGetterTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ITokenGetterTransactorRaw struct {
	Contract *ITokenGetterTransactor // Generic write-only contract binding to access the raw methods on
}

// NewITokenGetter creates a new instance of ITokenGetter, bound to a specific deployed contract.
func NewITokenGetter(address common.Address, backend bind.ContractBackend) (*ITokenGetter, error) {
	contract, err := bindITokenGetter(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ITokenGetter{ITokenGetterCaller: ITokenGetterCaller{contract: contract}, ITokenGetterTransactor: ITokenGetterTransactor{contract: contract}, ITokenGetterFilterer: ITokenGetterFilterer{contract: contract}}, nil
}

// NewITokenGetterCaller creates a new read-only instance of ITokenGetter, bound to a specific deployed contract.
func NewITokenGetterCaller(address common.Address, caller bind.ContractCaller) (*ITokenGetterCaller, error) {
	contract, err := bindITokenGetter(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ITokenGetterCaller{contract: contract}, nil
}

// NewITokenGetterTransactor creates a new write-only instance of ITokenGetter, bound to a specific deployed contract.
func NewITokenGetterTransactor(address common.Address, transactor bind.ContractTransactor) (*ITokenGetterTransactor, error) {
	contract, err := bindITokenGetter(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ITokenGetterTransactor{contract: contract}, nil
}

// NewITokenGetterFilterer creates a new log filterer instance of ITokenGetter, bound to a specific deployed contract.
func NewITokenGetterFilterer(address common.Address, filterer bind.ContractFilterer) (*ITokenGetterFilterer, error) {
	contract, err := bindITokenGetter(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ITokenGetterFilterer{contract: contract}, nil
}

// bindITokenGetter binds a generic wrapper to an already deployed contract.
func bindITokenGetter(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ITokenGetterABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ITokenGetter *ITokenGetterRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ITokenGetter.Contract.ITokenGetterCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ITokenGetter *ITokenGetterRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ITokenGetter.Contract.ITokenGetterTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ITokenGetter *ITokenGetterRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ITokenGetter.Contract.ITokenGetterTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ITokenGetter *ITokenGetterCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ITokenGetter.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ITokenGetter *ITokenGetterTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ITokenGetter.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ITokenGetter *ITokenGetterTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ITokenGetter.Contract.contract.Transact(opts, method, params...)
}

// CheckT is a free data retrieval call binding the contract method 0x81abb8fe.
//
// Solidity: function checkT(uint8 _ti) view returns(address, bool)
func (_ITokenGetter *ITokenGetterCaller) CheckT(opts *bind.CallOpts, _ti uint8) (common.Address, bool, error) {
	var out []interface{}
	err := _ITokenGetter.contract.Call(opts, &out, "checkT", _ti)

	if err != nil {
		return *new(common.Address), *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	out1 := *abi.ConvertType(out[1], new(bool)).(*bool)

	return out0, out1, err

}

// CheckT is a free data retrieval call binding the contract method 0x81abb8fe.
//
// Solidity: function checkT(uint8 _ti) view returns(address, bool)
func (_ITokenGetter *ITokenGetterSession) CheckT(_ti uint8) (common.Address, bool, error) {
	return _ITokenGetter.Contract.CheckT(&_ITokenGetter.CallOpts, _ti)
}

// CheckT is a free data retrieval call binding the contract method 0x81abb8fe.
//
// Solidity: function checkT(uint8 _ti) view returns(address, bool)
func (_ITokenGetter *ITokenGetterCallerSession) CheckT(_ti uint8) (common.Address, bool, error) {
	return _ITokenGetter.Contract.CheckT(&_ITokenGetter.CallOpts, _ti)
}

// GetTA is a free data retrieval call binding the contract method 0x8bb4a637.
//
// Solidity: function getTA(uint8 _ti) view returns(address)
func (_ITokenGetter *ITokenGetterCaller) GetTA(opts *bind.CallOpts, _ti uint8) (common.Address, error) {
	var out []interface{}
	err := _ITokenGetter.contract.Call(opts, &out, "getTA", _ti)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetTA is a free data retrieval call binding the contract method 0x8bb4a637.
//
// Solidity: function getTA(uint8 _ti) view returns(address)
func (_ITokenGetter *ITokenGetterSession) GetTA(_ti uint8) (common.Address, error) {
	return _ITokenGetter.Contract.GetTA(&_ITokenGetter.CallOpts, _ti)
}

// GetTA is a free data retrieval call binding the contract method 0x8bb4a637.
//
// Solidity: function getTA(uint8 _ti) view returns(address)
func (_ITokenGetter *ITokenGetterCallerSession) GetTA(_ti uint8) (common.Address, error) {
	return _ITokenGetter.Contract.GetTA(&_ITokenGetter.CallOpts, _ti)
}

// GetTCnt is a free data retrieval call binding the contract method 0x7600b86a.
//
// Solidity: function getTCnt() view returns(uint8)
func (_ITokenGetter *ITokenGetterCaller) GetTCnt(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _ITokenGetter.contract.Call(opts, &out, "getTCnt")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// GetTCnt is a free data retrieval call binding the contract method 0x7600b86a.
//
// Solidity: function getTCnt() view returns(uint8)
func (_ITokenGetter *ITokenGetterSession) GetTCnt() (uint8, error) {
	return _ITokenGetter.Contract.GetTCnt(&_ITokenGetter.CallOpts)
}

// GetTCnt is a free data retrieval call binding the contract method 0x7600b86a.
//
// Solidity: function getTCnt() view returns(uint8)
func (_ITokenGetter *ITokenGetterCallerSession) GetTCnt() (uint8, error) {
	return _ITokenGetter.Contract.GetTCnt(&_ITokenGetter.CallOpts)
}

// GetTI is a free data retrieval call binding the contract method 0x2df2685f.
//
// Solidity: function getTI(address _t) view returns(uint8, bool, bool)
func (_ITokenGetter *ITokenGetterCaller) GetTI(opts *bind.CallOpts, _t common.Address) (uint8, bool, bool, error) {
	var out []interface{}
	err := _ITokenGetter.contract.Call(opts, &out, "getTI", _t)

	if err != nil {
		return *new(uint8), *new(bool), *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)
	out1 := *abi.ConvertType(out[1], new(bool)).(*bool)
	out2 := *abi.ConvertType(out[2], new(bool)).(*bool)

	return out0, out1, out2, err

}

// GetTI is a free data retrieval call binding the contract method 0x2df2685f.
//
// Solidity: function getTI(address _t) view returns(uint8, bool, bool)
func (_ITokenGetter *ITokenGetterSession) GetTI(_t common.Address) (uint8, bool, bool, error) {
	return _ITokenGetter.Contract.GetTI(&_ITokenGetter.CallOpts, _t)
}

// GetTI is a free data retrieval call binding the contract method 0x2df2685f.
//
// Solidity: function getTI(address _t) view returns(uint8, bool, bool)
func (_ITokenGetter *ITokenGetterCallerSession) GetTI(_t common.Address) (uint8, bool, bool, error) {
	return _ITokenGetter.Contract.GetTI(&_ITokenGetter.CallOpts, _t)
}

// OwnerABI is the input ABI used to generate the binding from.
const OwnerABI = "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"name\":\"AddOwner\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"},{\"internalType\":\"bytes[5]\",\"name\":\"signs\",\"type\":\"bytes[5]\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]"

// OwnerFuncSigs maps the 4-byte function signature to its string representation.
var OwnerFuncSigs = map[string]string{
	"4bf1b134": "add(address,bool,bytes[5])",
	"de9375f2": "auth()",
	"022914a7": "owners(address)",
}

// OwnerBin is the compiled bytecode used for deploying new contracts.
var OwnerBin = "0x608060405234801561001057600080fd5b5060405161055838038061055883398101604081905261002f91610054565b600180546001600160a01b0319166001600160a01b0392909216919091179055610084565b60006020828403121561006657600080fd5b81516001600160a01b038116811461007d57600080fd5b9392505050565b6104c5806100936000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063022914a7146100465780634bf1b1341461007e578063de9375f214610093575b600080fd5b610069610054366004610257565b60006020819052908152604090205460ff1681565b60405190151581526020015b60405180910390f35b61009161008c3660046102e9565b6100be565b005b6001546100a6906001600160a01b031681565b6040516001600160a01b039091168152602001610075565b823b600081900361010a5760405162461bcd60e51b81526020600482015260126024820152713732b2b21031b7b73a3930b1ba1030b2323960711b604482015260640160405180910390fd5b6040516bffffffffffffffffffffffff1930606090811b821660208401526218591960ea1b603484015286901b16603782015283151560f81b604b820152600090604c0160408051601f1981840301815290829052805160209091012060015463a96bba9d60e01b83529092506001600160a01b03169063a96bba9d9061019790849087906004016103ff565b600060405180830381600087803b1580156101b157600080fd5b505af11580156101c5573d6000803e3d6000fd5b5050604080516001600160a01b038916815287151560208201527f938b2a24c98e4e542127ffa74a91e48942c2bddccae3b6d75f82bfda7bbc0807935001905060405180910390a15050506001600160a01b03919091166000908152602081905260409020805460ff1916911515919091179055565b80356001600160a01b038116811461025257600080fd5b919050565b60006020828403121561026957600080fd5b6102728261023b565b9392505050565b634e487b7160e01b600052604160045260246000fd5b60405160a0810167ffffffffffffffff811182821017156102b2576102b2610279565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156102e1576102e1610279565b604052919050565b6000806000606084860312156102fe57600080fd5b6103078461023b565b9250602080850135801515811461031d57600080fd5b9250604085013567ffffffffffffffff8082111561033a57600080fd5b8187019150601f888184011261034f57600080fd5b61035761028f565b8060a085018b81111561036957600080fd5b855b818110156103ed578035868111156103835760008081fd5b87018581018e136103945760008081fd5b8035878111156103a6576103a6610279565b6103b7818801601f19168b016102b8565b8181528f8b8385010111156103cc5760008081fd5b818b84018c83013760009181018b019190915285525092870192870161036b565b50508096505050505050509250925092565b8281526040602080830182905260009160e08401919084018584805b600581101561048157878603603f1901845282518051808852835b81811015610451578281018801518982018901528701610436565b81811115610461578488838b0101525b50601f01601f19169690960185019550928401929184019160010161041b565b50939897505050505050505056fea2646970667358221220e4109531dbabeb33ccbfa77f28019b7953ba57d32bea8b64099ee0dd97784c0464736f6c634300080e0033"

// DeployOwner deploys a new Ethereum contract, binding an instance of Owner to it.
func DeployOwner(auth *bind.TransactOpts, backend bind.ContractBackend, _a common.Address) (common.Address, *types.Transaction, *Owner, error) {
	parsed, err := abi.JSON(strings.NewReader(OwnerABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(OwnerBin), backend, _a)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Owner{OwnerCaller: OwnerCaller{contract: contract}, OwnerTransactor: OwnerTransactor{contract: contract}, OwnerFilterer: OwnerFilterer{contract: contract}}, nil
}

// Owner is an auto generated Go binding around an Ethereum contract.
type Owner struct {
	OwnerCaller     // Read-only binding to the contract
	OwnerTransactor // Write-only binding to the contract
	OwnerFilterer   // Log filterer for contract events
}

// OwnerCaller is an auto generated read-only Go binding around an Ethereum contract.
type OwnerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type OwnerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OwnerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OwnerSession struct {
	Contract     *Owner            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OwnerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OwnerCallerSession struct {
	Contract *OwnerCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// OwnerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OwnerTransactorSession struct {
	Contract     *OwnerTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OwnerRaw is an auto generated low-level Go binding around an Ethereum contract.
type OwnerRaw struct {
	Contract *Owner // Generic contract binding to access the raw methods on
}

// OwnerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OwnerCallerRaw struct {
	Contract *OwnerCaller // Generic read-only contract binding to access the raw methods on
}

// OwnerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OwnerTransactorRaw struct {
	Contract *OwnerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOwner creates a new instance of Owner, bound to a specific deployed contract.
func NewOwner(address common.Address, backend bind.ContractBackend) (*Owner, error) {
	contract, err := bindOwner(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Owner{OwnerCaller: OwnerCaller{contract: contract}, OwnerTransactor: OwnerTransactor{contract: contract}, OwnerFilterer: OwnerFilterer{contract: contract}}, nil
}

// NewOwnerCaller creates a new read-only instance of Owner, bound to a specific deployed contract.
func NewOwnerCaller(address common.Address, caller bind.ContractCaller) (*OwnerCaller, error) {
	contract, err := bindOwner(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OwnerCaller{contract: contract}, nil
}

// NewOwnerTransactor creates a new write-only instance of Owner, bound to a specific deployed contract.
func NewOwnerTransactor(address common.Address, transactor bind.ContractTransactor) (*OwnerTransactor, error) {
	contract, err := bindOwner(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OwnerTransactor{contract: contract}, nil
}

// NewOwnerFilterer creates a new log filterer instance of Owner, bound to a specific deployed contract.
func NewOwnerFilterer(address common.Address, filterer bind.ContractFilterer) (*OwnerFilterer, error) {
	contract, err := bindOwner(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OwnerFilterer{contract: contract}, nil
}

// bindOwner binds a generic wrapper to an already deployed contract.
func bindOwner(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(OwnerABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Owner *OwnerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Owner.Contract.OwnerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Owner *OwnerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Owner.Contract.OwnerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Owner *OwnerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Owner.Contract.OwnerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Owner *OwnerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Owner.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Owner *OwnerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Owner.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Owner *OwnerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Owner.Contract.contract.Transact(opts, method, params...)
}

// Auth is a free data retrieval call binding the contract method 0xde9375f2.
//
// Solidity: function auth() view returns(address)
func (_Owner *OwnerCaller) Auth(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Owner.contract.Call(opts, &out, "auth")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Auth is a free data retrieval call binding the contract method 0xde9375f2.
//
// Solidity: function auth() view returns(address)
func (_Owner *OwnerSession) Auth() (common.Address, error) {
	return _Owner.Contract.Auth(&_Owner.CallOpts)
}

// Auth is a free data retrieval call binding the contract method 0xde9375f2.
//
// Solidity: function auth() view returns(address)
func (_Owner *OwnerCallerSession) Auth() (common.Address, error) {
	return _Owner.Contract.Auth(&_Owner.CallOpts)
}

// Owners is a free data retrieval call binding the contract method 0x022914a7.
//
// Solidity: function owners(address ) view returns(bool)
func (_Owner *OwnerCaller) Owners(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _Owner.contract.Call(opts, &out, "owners", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Owners is a free data retrieval call binding the contract method 0x022914a7.
//
// Solidity: function owners(address ) view returns(bool)
func (_Owner *OwnerSession) Owners(arg0 common.Address) (bool, error) {
	return _Owner.Contract.Owners(&_Owner.CallOpts, arg0)
}

// Owners is a free data retrieval call binding the contract method 0x022914a7.
//
// Solidity: function owners(address ) view returns(bool)
func (_Owner *OwnerCallerSession) Owners(arg0 common.Address) (bool, error) {
	return _Owner.Contract.Owners(&_Owner.CallOpts, arg0)
}

// Add is a paid mutator transaction binding the contract method 0x4bf1b134.
//
// Solidity: function add(address _a, bool isSet, bytes[5] signs) returns()
func (_Owner *OwnerTransactor) Add(opts *bind.TransactOpts, _a common.Address, isSet bool, signs [5][]byte) (*types.Transaction, error) {
	return _Owner.contract.Transact(opts, "add", _a, isSet, signs)
}

// Add is a paid mutator transaction binding the contract method 0x4bf1b134.
//
// Solidity: function add(address _a, bool isSet, bytes[5] signs) returns()
func (_Owner *OwnerSession) Add(_a common.Address, isSet bool, signs [5][]byte) (*types.Transaction, error) {
	return _Owner.Contract.Add(&_Owner.TransactOpts, _a, isSet, signs)
}

// Add is a paid mutator transaction binding the contract method 0x4bf1b134.
//
// Solidity: function add(address _a, bool isSet, bytes[5] signs) returns()
func (_Owner *OwnerTransactorSession) Add(_a common.Address, isSet bool, signs [5][]byte) (*types.Transaction, error) {
	return _Owner.Contract.Add(&_Owner.TransactOpts, _a, isSet, signs)
}

// OwnerAddOwnerIterator is returned from FilterAddOwner and is used to iterate over the raw logs and unpacked data for AddOwner events raised by the Owner contract.
type OwnerAddOwnerIterator struct {
	Event *OwnerAddOwner // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OwnerAddOwnerIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OwnerAddOwner)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OwnerAddOwner)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OwnerAddOwnerIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OwnerAddOwnerIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OwnerAddOwner represents a AddOwner event raised by the Owner contract.
type OwnerAddOwner struct {
	From  common.Address
	IsSet bool
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterAddOwner is a free log retrieval operation binding the contract event 0x938b2a24c98e4e542127ffa74a91e48942c2bddccae3b6d75f82bfda7bbc0807.
//
// Solidity: event AddOwner(address from, bool isSet)
func (_Owner *OwnerFilterer) FilterAddOwner(opts *bind.FilterOpts) (*OwnerAddOwnerIterator, error) {

	logs, sub, err := _Owner.contract.FilterLogs(opts, "AddOwner")
	if err != nil {
		return nil, err
	}
	return &OwnerAddOwnerIterator{contract: _Owner.contract, event: "AddOwner", logs: logs, sub: sub}, nil
}

// WatchAddOwner is a free log subscription operation binding the contract event 0x938b2a24c98e4e542127ffa74a91e48942c2bddccae3b6d75f82bfda7bbc0807.
//
// Solidity: event AddOwner(address from, bool isSet)
func (_Owner *OwnerFilterer) WatchAddOwner(opts *bind.WatchOpts, sink chan<- *OwnerAddOwner) (event.Subscription, error) {

	logs, sub, err := _Owner.contract.WatchLogs(opts, "AddOwner")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OwnerAddOwner)
				if err := _Owner.contract.UnpackLog(event, "AddOwner", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddOwner is a log parse operation binding the contract event 0x938b2a24c98e4e542127ffa74a91e48942c2bddccae3b6d75f82bfda7bbc0807.
//
// Solidity: event AddOwner(address from, bool isSet)
func (_Owner *OwnerFilterer) ParseAddOwner(log types.Log) (*OwnerAddOwner, error) {
	event := new(OwnerAddOwner)
	if err := _Owner.contract.UnpackLog(event, "AddOwner", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RecoverABI is the input ABI used to generate the binding from.
const RecoverABI = "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"recover\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]"

// RecoverFuncSigs maps the 4-byte function signature to its string representation.
var RecoverFuncSigs = map[string]string{
	"19045a25": "recover(bytes32,bytes)",
}

// RecoverBin is the compiled bytecode used for deploying new contracts.
var RecoverBin = "0x6102a861003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100355760003560e01c806319045a251461003a575b600080fd5b61004d610048366004610184565b610069565b6040516001600160a01b03909116815260200160405180910390f35b6000815160411461007c57506000610168565b60208201516040830151606084015160001a7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08211156100c25760009350505050610168565b601b8160ff1610156100dc576100d981601b61023f565b90505b8060ff16601b141580156100f457508060ff16601c14155b156101055760009350505050610168565b60408051600081526020810180835288905260ff831691810191909152606081018490526080810183905260019060a0016020604051602081039080840390855afa158015610158573d6000803e3d6000fd5b5050506020604051035193505050505b92915050565b634e487b7160e01b600052604160045260246000fd5b6000806040838503121561019757600080fd5b82359150602083013567ffffffffffffffff808211156101b657600080fd5b818501915085601f8301126101ca57600080fd5b8135818111156101dc576101dc61016e565b604051601f8201601f19908116603f011681019083821181831017156102045761020461016e565b8160405282815288602084870101111561021d57600080fd5b8260208601602083013760006020848301015280955050505050509250929050565b600060ff821660ff84168060ff0382111561026a57634e487b7160e01b600052601160045260246000fd5b01939250505056fea26469706673582212200d88ed66bdb84578aad3e4db894d00f01a13c6b71be38cba41e6c2a7a75b243364736f6c634300080e0033"

// DeployRecover deploys a new Ethereum contract, binding an instance of Recover to it.
func DeployRecover(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Recover, error) {
	parsed, err := abi.JSON(strings.NewReader(RecoverABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(RecoverBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Recover{RecoverCaller: RecoverCaller{contract: contract}, RecoverTransactor: RecoverTransactor{contract: contract}, RecoverFilterer: RecoverFilterer{contract: contract}}, nil
}

// Recover is an auto generated Go binding around an Ethereum contract.
type Recover struct {
	RecoverCaller     // Read-only binding to the contract
	RecoverTransactor // Write-only binding to the contract
	RecoverFilterer   // Log filterer for contract events
}

// RecoverCaller is an auto generated read-only Go binding around an Ethereum contract.
type RecoverCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RecoverTransactor is an auto generated write-only Go binding around an Ethereum contract.
type RecoverTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RecoverFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type RecoverFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RecoverSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type RecoverSession struct {
	Contract     *Recover          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// RecoverCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type RecoverCallerSession struct {
	Contract *RecoverCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// RecoverTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type RecoverTransactorSession struct {
	Contract     *RecoverTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// RecoverRaw is an auto generated low-level Go binding around an Ethereum contract.
type RecoverRaw struct {
	Contract *Recover // Generic contract binding to access the raw methods on
}

// RecoverCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type RecoverCallerRaw struct {
	Contract *RecoverCaller // Generic read-only contract binding to access the raw methods on
}

// RecoverTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type RecoverTransactorRaw struct {
	Contract *RecoverTransactor // Generic write-only contract binding to access the raw methods on
}

// NewRecover creates a new instance of Recover, bound to a specific deployed contract.
func NewRecover(address common.Address, backend bind.ContractBackend) (*Recover, error) {
	contract, err := bindRecover(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Recover{RecoverCaller: RecoverCaller{contract: contract}, RecoverTransactor: RecoverTransactor{contract: contract}, RecoverFilterer: RecoverFilterer{contract: contract}}, nil
}

// NewRecoverCaller creates a new read-only instance of Recover, bound to a specific deployed contract.
func NewRecoverCaller(address common.Address, caller bind.ContractCaller) (*RecoverCaller, error) {
	contract, err := bindRecover(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &RecoverCaller{contract: contract}, nil
}

// NewRecoverTransactor creates a new write-only instance of Recover, bound to a specific deployed contract.
func NewRecoverTransactor(address common.Address, transactor bind.ContractTransactor) (*RecoverTransactor, error) {
	contract, err := bindRecover(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &RecoverTransactor{contract: contract}, nil
}

// NewRecoverFilterer creates a new log filterer instance of Recover, bound to a specific deployed contract.
func NewRecoverFilterer(address common.Address, filterer bind.ContractFilterer) (*RecoverFilterer, error) {
	contract, err := bindRecover(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &RecoverFilterer{contract: contract}, nil
}

// bindRecover binds a generic wrapper to an already deployed contract.
func bindRecover(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(RecoverABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Recover *RecoverRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Recover.Contract.RecoverCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Recover *RecoverRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Recover.Contract.RecoverTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Recover *RecoverRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Recover.Contract.RecoverTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Recover *RecoverCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Recover.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Recover *RecoverTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Recover.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Recover *RecoverTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Recover.Contract.contract.Transact(opts, method, params...)
}

// Recover is a free data retrieval call binding the contract method 0x19045a25.
//
// Solidity: function recover(bytes32 hash, bytes signature) pure returns(address)
func (_Recover *RecoverCaller) Recover(opts *bind.CallOpts, hash [32]byte, signature []byte) (common.Address, error) {
	var out []interface{}
	err := _Recover.contract.Call(opts, &out, "recover", hash, signature)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Recover is a free data retrieval call binding the contract method 0x19045a25.
//
// Solidity: function recover(bytes32 hash, bytes signature) pure returns(address)
func (_Recover *RecoverSession) Recover(hash [32]byte, signature []byte) (common.Address, error) {
	return _Recover.Contract.Recover(&_Recover.CallOpts, hash, signature)
}

// Recover is a free data retrieval call binding the contract method 0x19045a25.
//
// Solidity: function recover(bytes32 hash, bytes signature) pure returns(address)
func (_Recover *RecoverCallerSession) Recover(hash [32]byte, signature []byte) (common.Address, error) {
	return _Recover.Contract.Recover(&_Recover.CallOpts, hash, signature)
}
